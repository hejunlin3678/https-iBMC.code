import { Injectable, RendererFactory2 } from '@angular/core';
import { TiRenderer } from '../renderer/TiRenderer';
import { TiLog, Util } from '../../utils/Util';
import { TiTipService } from '../tip/TiTipService';
import { TiOverflowServiceModule } from './TiOverflowServiceModule';
import * as i0 from "@angular/core";
import * as i1 from "../renderer/TiRenderer";
import * as i2 from "../tip/TiTipService";
import * as i3 from "./TiOverflowServiceModule";
/**
 * @ignore
 * 文本过长出...并tip提示配置项，使用该服务时需要引入模块TiOverflowServiceModule，该组件提供了两种使用方式:
 *
 * 1.服务方式（见如下说明）
 *
 * 2.指令方式：[TiOverflowDirective]{@link ../directives/TiOverflowDirective.html}
 *
 * <example-url>../tiny3demo/#/overflow/overflow-all</example-url>
 */
export class TiOverflowService {
    constructor(rendererFactory, tiRenderer, tipService) {
        this.tiRenderer = tiRenderer;
        this.tipService = tipService;
        /* tslint:disable:no-null-keyword */
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    /**
     * 生成tip提示方法
     * @param hostElement 文本过长的宿主对象
     * @param config overflow配置项
     * 返回 {destroy(): void} 销毁文本过长的tip提示，使用服务方式时，需要在宿主元素销毁时，通过调用该方法销毁文本过长的tip提示
     */
    create(hostElement, config) {
        this.tiRenderer.setStyles(hostElement, {
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            overflow: 'hidden'
        });
        // 非法情况处理
        if (!Util.isElement(hostElement)) {
            TiLog.warn('overflow: hostEle type is not element');
            // 防止外部使用报错，此处做返回值处理
            return {
                destroy() { }
            };
        }
        // 如果该元素为inline元素时，宽度不生效会导致元素出...样式不生效，因此此处做处理
        // 修复SSR报错：ERROR ReferenceError: getComputedStyle is not defined
        if (typeof getComputedStyle !== 'undefined' && getComputedStyle(hostElement).display === 'inline') {
            this.renderer.setStyle(hostElement, 'display', 'inline-block');
        }
        const tipInstance = this.generateTip(hostElement, config || {});
        return {
            destroy() {
                if (tipInstance) {
                    tipInstance.hide();
                }
            }
        };
    }
    /**
     * @ignore
     */
    isOverflow(element) {
        // 复制DOM，并计算元素宽度
        // 此处使用clone方式而不使用scrollWidth方式,是因为目前发现scrollWidth在IE下获取到的值有问题，不可作为文本溢出的判断条件
        const eleStyles = getComputedStyle(element);
        const cloneEle = element.cloneNode(true);
        this.tiRenderer.setStyles(cloneEle, {
            // 涉及内容字体的相关样式处理
            fontSize: eleStyles.fontSize,
            fontWeight: eleStyles.fontWeight,
            fontFamily: eleStyles.fontFamily,
            padding: eleStyles.padding,
            paddingLeft: eleStyles.paddingLeft,
            paddingRight: eleStyles.paddingRight,
            border: eleStyles.border,
            boxSizing: eleStyles.boxSizing,
            height: eleStyles.height,
            // 涉及宽度布局的相关样式处理
            maxWidth: 'none',
            width: 'auto',
            overflow: 'visible',
            display: 'inline-block',
            visibility: 'hidden',
            whiteSpace: 'nowrap',
            position: 'absolute',
            left: '-9999px',
            top: '-9999px'
        });
        this.renderer.appendChild(document.body, cloneEle);
        // 使用getBoundingClientRect而不使用getComputedStyle,是因为getComputedStyle在
        // 各浏览器获取到的宽度不一致（IE下取到的是内容宽度，而在Chrome和FF下取到的是整个元素宽度）。
        // IE下计算精度高(小数点后15位)，多数中文和数字或英文混排的文本计算出来的 maxWidth 和 textWidth
        // 由于精度高而导致有微小差距，从而影响了 isOverflow 的判断结果，从实际测试得来结论：保留两位小数能够保证判断结果更准确些。
        const maxWidth = parseFloat(element.getBoundingClientRect().width
            .toFixed(2));
        const textWidth = parseFloat(cloneEle.getBoundingClientRect().width
            .toFixed(2));
        // 此处没有使用angular的Renderer2是因为Renderer2.removeChild必须有变化检测才能在dom上生效，
        // 此处考虑到性能不触发变化检测，所以选择使用原生的removeChild方法。
        document.body.removeChild(cloneEle);
        return textWidth > maxWidth;
    }
    generateTip(element, options) {
        // 文本超长时，显示tip提示：
        // tip显示位置元素设置：默认为element
        const config = options || {};
        let hostEleConfig = config.tipElement;
        if (typeof hostEleConfig === 'function') {
            hostEleConfig = hostEleConfig(element);
        }
        const tipHostEle = hostEleConfig || element;
        return this.tipService.create(tipHostEle, {
            hostEleX: config.tipHostEleX,
            position: config.tipPosition,
            maxWidth: config.tipMaxWidth,
            trigger: 'mouse',
            showFn: () => {
                // tipContent 为空 或者 未溢出情况下，不显示tip
                // tipPosition设置为none是去除Select默认超长tip，改由template内容自定义tip
                if (config.tipPosition === 'none' || config.tipContent === '' || !this.isOverflow(element)) {
                    return;
                }
                // tip内容设置：默认为元素中的文本内容
                let tipContent = config.tipContent;
                if (Util.isUndefined(tipContent)) { // content可能为""，因此此处判断undefined而不使用||
                    tipContent = element.textContent;
                }
                return { content: tipContent };
            }
        });
    }
}
TiOverflowService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TiOverflowService_Factory() { return new TiOverflowService(i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(i1.TiRenderer), i0.ɵɵinject(i2.TiTipService)); }, token: TiOverflowService, providedIn: i3.TiOverflowServiceModule });
TiOverflowService.decorators = [
    { type: Injectable, args: [{
                providedIn: TiOverflowServiceModule
            },] }
];
TiOverflowService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: TiRenderer },
    { type: TiTipService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGlPdmVyZmxvd1NlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9AY2xvdWQvdGlueTMvc2VydmljZXMvb3ZlcmZsb3cvVGlPdmVyZmxvd1NlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFnQixVQUFVLEVBQWEsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEYsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFHL0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ25ELE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDOzs7OztBQW9DcEU7Ozs7Ozs7OztHQVNHO0FBSUgsTUFBTSxPQUFPLGlCQUFpQjtJQUUxQixZQUFZLGVBQWlDLEVBQ3pCLFVBQXNCLEVBQ3RCLFVBQXdCO1FBRHhCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsZUFBVSxHQUFWLFVBQVUsQ0FBYztRQUNwQyxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBQ0Q7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsV0FBb0IsRUFBRSxNQUF5QjtRQUNsRCxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUU7WUFDbkMsVUFBVSxFQUFFLFFBQVE7WUFDcEIsWUFBWSxFQUFFLFVBQVU7WUFDeEIsUUFBUSxFQUFFLFFBQVE7U0FDckIsQ0FBQyxDQUFDO1FBQ0gsU0FBUztRQUNULElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQzlCLEtBQUssQ0FBQyxJQUFJLENBQUMsdUNBQXVDLENBQUMsQ0FBQztZQUVwRCxvQkFBb0I7WUFDcEIsT0FBTztnQkFDSCxPQUFPLEtBQVUsQ0FBQzthQUNyQixDQUFDO1NBQ0w7UUFDRCw4Q0FBOEM7UUFDOUMsZ0VBQWdFO1FBQ2hFLElBQUksT0FBTyxnQkFBZ0IsS0FBSSxXQUFXLElBQUksZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUM5RixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1NBQ2xFO1FBQ0QsTUFBTSxXQUFXLEdBQWEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRTFFLE9BQU87WUFDSCxPQUFPO2dCQUNILElBQUksV0FBVyxFQUFFO29CQUNiLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztpQkFDdEI7WUFDTCxDQUFDO1NBQ0osQ0FBQztJQUNOLENBQUM7SUFDRDs7T0FFRztJQUNJLFVBQVUsQ0FBQyxPQUFnQjtRQUM5QixnQkFBZ0I7UUFDaEIsNEVBQTRFO1FBQzVFLE1BQU0sU0FBUyxHQUFRLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2pELE1BQU0sUUFBUSxHQUFRLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO1lBQ2hDLGdCQUFnQjtZQUNoQixRQUFRLEVBQUUsU0FBUyxDQUFDLFFBQVE7WUFDNUIsVUFBVSxFQUFFLFNBQVMsQ0FBQyxVQUFVO1lBQ2hDLFVBQVUsRUFBRSxTQUFTLENBQUMsVUFBVTtZQUNoQyxPQUFPLEVBQUUsU0FBUyxDQUFDLE9BQU87WUFDMUIsV0FBVyxFQUFFLFNBQVMsQ0FBQyxXQUFXO1lBQ2xDLFlBQVksRUFBRSxTQUFTLENBQUMsWUFBWTtZQUNwQyxNQUFNLEVBQUUsU0FBUyxDQUFDLE1BQU07WUFDeEIsU0FBUyxFQUFFLFNBQVMsQ0FBQyxTQUFTO1lBQzlCLE1BQU0sRUFBRSxTQUFTLENBQUMsTUFBTTtZQUN4QixnQkFBZ0I7WUFDaEIsUUFBUSxFQUFFLE1BQU07WUFDaEIsS0FBSyxFQUFFLE1BQU07WUFDYixRQUFRLEVBQUUsU0FBUztZQUNuQixPQUFPLEVBQUUsY0FBYztZQUN2QixVQUFVLEVBQUUsUUFBUTtZQUNwQixVQUFVLEVBQUUsUUFBUTtZQUNwQixRQUFRLEVBQUUsVUFBVTtZQUNwQixJQUFJLEVBQUUsU0FBUztZQUNmLEdBQUcsRUFBRSxTQUFTO1NBRWpCLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDbkQsbUVBQW1FO1FBQ25FLHFEQUFxRDtRQUNyRCw4REFBOEQ7UUFDOUQscUVBQXFFO1FBQ3JFLE1BQU0sUUFBUSxHQUFXLFVBQVUsQ0FBQyxPQUFPLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLO2FBQ3BFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pCLE1BQU0sU0FBUyxHQUFXLFVBQVUsQ0FBQyxRQUFRLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLO2FBQ3RFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pCLG1FQUFtRTtRQUNuRSx5Q0FBeUM7UUFDekMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFcEMsT0FBTyxTQUFTLEdBQUcsUUFBUSxDQUFDO0lBQ2hDLENBQUM7SUFDTyxXQUFXLENBQUMsT0FBZ0IsRUFBRSxPQUF5QjtRQUMzRCxpQkFBaUI7UUFDakIseUJBQXlCO1FBQ3pCLE1BQU0sTUFBTSxHQUFxQixPQUFPLElBQUksRUFBRSxDQUFDO1FBQy9DLElBQUksYUFBYSxHQUFRLE1BQU0sQ0FBQyxVQUFVLENBQUM7UUFDM0MsSUFBSSxPQUFPLGFBQWEsS0FBSyxVQUFVLEVBQUU7WUFDckMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMxQztRQUNELE1BQU0sVUFBVSxHQUFZLGFBQWEsSUFBSSxPQUFPLENBQUM7UUFFckQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUU7WUFDdEMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxXQUFXO1lBQzVCLFFBQVEsRUFBRSxNQUFNLENBQUMsV0FBVztZQUM1QixRQUFRLEVBQUUsTUFBTSxDQUFDLFdBQVc7WUFDNUIsT0FBTyxFQUFFLE9BQU87WUFDaEIsTUFBTSxFQUFFLEdBQWtCLEVBQUU7Z0JBQ3hCLGlDQUFpQztnQkFDakMsd0RBQXdEO2dCQUN4RCxJQUFJLE1BQU0sQ0FBQyxXQUFXLEtBQUssTUFBTSxJQUFJLE1BQU0sQ0FBQyxVQUFVLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFDeEYsT0FBTztpQkFDVjtnQkFDRCxzQkFBc0I7Z0JBQ3RCLElBQUksVUFBVSxHQUFXLE1BQU0sQ0FBQyxVQUFVLENBQUM7Z0JBQzNDLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLHFDQUFxQztvQkFDckUsVUFBVSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUM7aUJBQ3BDO2dCQUVELE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUM7WUFDbkMsQ0FBQztTQUNKLENBQUMsQ0FBQztJQUNQLENBQUM7Ozs7WUEzSEosVUFBVSxTQUFDO2dCQUNSLFVBQVUsRUFBRSx1QkFBdUI7YUFDcEM7OztZQXREMkMsZ0JBQWdCO1lBQ3JELFVBQVU7WUFJVixZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50UmVmLCBJbmplY3RhYmxlLCBSZW5kZXJlcjIsIFJlbmRlcmVyRmFjdG9yeTIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVGlSZW5kZXJlciB9IGZyb20gJy4uL3JlbmRlcmVyL1RpUmVuZGVyZXInO1xyXG5pbXBvcnQgeyBUaUxvZywgVXRpbCB9IGZyb20gJy4uLy4uL3V0aWxzL1V0aWwnO1xyXG5pbXBvcnQgeyBUaVBvc2l0aW9uVHlwZSB9IGZyb20gJy4uLy4uL3V0aWxzL1Bvc2l0aW9uJztcclxuaW1wb3J0IHsgVGlUaXBSZWYsIFRpVGlwU2hvd0luZm8gfSBmcm9tICcuLi90aXAvVGlUaXBJbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBUaVRpcFNlcnZpY2UgfSBmcm9tICcuLi90aXAvVGlUaXBTZXJ2aWNlJztcclxuaW1wb3J0IHsgVGlPdmVyZmxvd1NlcnZpY2VNb2R1bGUgfSBmcm9tICcuL1RpT3ZlcmZsb3dTZXJ2aWNlTW9kdWxlJztcclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIG92ZXJmbG936YWN572u6aG55o6l5Y+j77yM55So5LqOW1RpT3ZlcmZsb3dTZXJ2aWNlLmNyZWF0ZV17QGxpbmsgLi4vaW5qZWN0YWJsZXMvVGlPdmVyZmxvd1NlcnZpY2UuaHRtbCNjcmVhdGV95Y+C5pWw5L2/55SoXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFRpT3ZlcmZsb3dDb25maWcge1xyXG4gICAgLyoqXHJcbiAgICAgKiB0aXDmmL7npLrml7bmiYDkvp3mja7nmoTlhYPntKDvvIzkvb/nlKjor6XlhYPntKDkvY3nva7mmL7npLp0aXDkvY3nva7vvIzpu5jorqTkuLrlrr/kuLvlhYPntKAs5b2TdGlw5pi+56S65omA5L6d6LWW55qE5YWD57Sg55qE5ZKM5a6/5Li75YWD57Sg5LiN5LiA6Ie05pe25omN6ZyA6KaB5a6a5LmJXHJcbiAgICAgKi9cclxuICAgIHRpcEVsZW1lbnQ/OiBFbGVtZW50IHwgRnVuY3Rpb247XHJcbiAgICAvKipcclxuICAgICAqIHRpcOWGheWuue+8jOm7mOiupOS4uuWuv+S4u+WFg+e0oOaWh+acrFxyXG4gICAgICovXHJcbiAgICB0aXBDb250ZW50Pzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiB0aXDkvY3nva5cclxuICAgICAqL1xyXG4gICAgdGlwUG9zaXRpb24/OiBUaVBvc2l0aW9uVHlwZTtcclxuICAgIC8qKlxyXG4gICAgICogdGlw5pyA5aSn5a695bqmXHJcbiAgICAgKi9cclxuICAgIHRpcE1heFdpZHRoPzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKiDlhrPlrprlrprkvY3lhYPntKDmsLTlubPmlrnlkJHnmoTlhYPntKDvvIznlKjkuo7lrr/kuLvlhYPntKDmsLTlubPmlrnlkJHkvY3nva7kuI5ob3N05YWD57Sg5LiN5LiA6Ie055qE5Zy65pmv77yM5pqC5LiN5a+55aSW5byA5pS+XHJcbiAgICAgKi9cclxuICAgIHRpcEhvc3RFbGVYPzogRWxlbWVudDtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKiBjcmVhdGXmlrnms5Xov5Tlm57lgLxcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGlPdmVyZmxvd1JlZiB7XHJcbiAgICBkZXN0cm95KCk6IHZvaWQ7XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICog5paH5pys6L+H6ZW/5Ye6Li4u5bm2dGlw5o+Q56S66YWN572u6aG577yM5L2/55So6K+l5pyN5Yqh5pe26ZyA6KaB5byV5YWl5qih5Z2XVGlPdmVyZmxvd1NlcnZpY2VNb2R1bGXvvIzor6Xnu4Tku7bmj5DkvpvkuobkuKTnp43kvb/nlKjmlrnlvI86XHJcbiAqXHJcbiAqIDEu5pyN5Yqh5pa55byP77yI6KeB5aaC5LiL6K+05piO77yJXHJcbiAqXHJcbiAqIDIu5oyH5Luk5pa55byP77yaW1RpT3ZlcmZsb3dEaXJlY3RpdmVde0BsaW5rIC4uL2RpcmVjdGl2ZXMvVGlPdmVyZmxvd0RpcmVjdGl2ZS5odG1sfVxyXG4gKlxyXG4gKiA8ZXhhbXBsZS11cmw+Li4vdGlueTNkZW1vLyMvb3ZlcmZsb3cvb3ZlcmZsb3ctYWxsPC9leGFtcGxlLXVybD5cclxuICovXHJcbkBJbmplY3RhYmxlKHtcclxuICAgIHByb3ZpZGVkSW46IFRpT3ZlcmZsb3dTZXJ2aWNlTW9kdWxlXHJcbiAgfSlcclxuZXhwb3J0IGNsYXNzIFRpT3ZlcmZsb3dTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMjtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5MixcclxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGlSZW5kZXJlcjogVGlSZW5kZXJlcixcclxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGlwU2VydmljZTogVGlUaXBTZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLW51bGwta2V5d29yZCAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJB0aXDmj5DnpLrmlrnms5VcclxuICAgICAqIEBwYXJhbSBob3N0RWxlbWVudCDmlofmnKzov4fplb/nmoTlrr/kuLvlr7nosaFcclxuICAgICAqIEBwYXJhbSBjb25maWcgb3ZlcmZsb3fphY3nva7poblcclxuICAgICAqIOi/lOWbniB7ZGVzdHJveSgpOiB2b2lkfSDplIDmr4HmlofmnKzov4fplb/nmoR0aXDmj5DnpLrvvIzkvb/nlKjmnI3liqHmlrnlvI/ml7bvvIzpnIDopoHlnKjlrr/kuLvlhYPntKDplIDmr4Hml7bvvIzpgJrov4fosIPnlKjor6Xmlrnms5XplIDmr4HmlofmnKzov4fplb/nmoR0aXDmj5DnpLpcclxuICAgICAqL1xyXG4gICAgY3JlYXRlKGhvc3RFbGVtZW50OiBFbGVtZW50LCBjb25maWc/OiBUaU92ZXJmbG93Q29uZmlnKTogVGlPdmVyZmxvd1JlZiB7XHJcbiAgICAgICAgdGhpcy50aVJlbmRlcmVyLnNldFN0eWxlcyhob3N0RWxlbWVudCwge1xyXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcclxuICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyDpnZ7ms5Xmg4XlhrXlpITnkIZcclxuICAgICAgICBpZiAoIVV0aWwuaXNFbGVtZW50KGhvc3RFbGVtZW50KSkge1xyXG4gICAgICAgICAgICBUaUxvZy53YXJuKCdvdmVyZmxvdzogaG9zdEVsZSB0eXBlIGlzIG5vdCBlbGVtZW50Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyDpmLLmraLlpJbpg6jkvb/nlKjmiqXplJnvvIzmraTlpITlgZrov5Tlm57lgLzlpITnkIZcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRlc3Ryb3koKTogdm9pZCB7fVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlpoLmnpzor6XlhYPntKDkuLppbmxpbmXlhYPntKDml7bvvIzlrr3luqbkuI3nlJ/mlYjkvJrlr7zoh7TlhYPntKDlh7ouLi7moLflvI/kuI3nlJ/mlYjvvIzlm6DmraTmraTlpITlgZrlpITnkIZcclxuICAgICAgICAvLyDkv67lpI1TU1LmiqXplJnvvJpFUlJPUiBSZWZlcmVuY2VFcnJvcjogZ2V0Q29tcHV0ZWRTdHlsZSBpcyBub3QgZGVmaW5lZFxyXG4gICAgICAgIGlmICh0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZSAhPT0ndW5kZWZpbmVkJyAmJiBnZXRDb21wdXRlZFN0eWxlKGhvc3RFbGVtZW50KS5kaXNwbGF5ID09PSAnaW5saW5lJykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGhvc3RFbGVtZW50LCAnZGlzcGxheScsICdpbmxpbmUtYmxvY2snKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGlwSW5zdGFuY2U6IFRpVGlwUmVmID0gdGhpcy5nZW5lcmF0ZVRpcChob3N0RWxlbWVudCwgY29uZmlnIHx8IHt9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aXBJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpcEluc3RhbmNlLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzT3ZlcmZsb3coZWxlbWVudDogRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIOWkjeWItkRPTe+8jOW5tuiuoeeul+WFg+e0oOWuveW6plxyXG4gICAgICAgIC8vIOatpOWkhOS9v+eUqGNsb25l5pa55byP6ICM5LiN5L2/55Soc2Nyb2xsV2lkdGjmlrnlvI8s5piv5Zug5Li655uu5YmN5Y+R546wc2Nyb2xsV2lkdGjlnKhJReS4i+iOt+WPluWIsOeahOWAvOaciemXrumimO+8jOS4jeWPr+S9nOS4uuaWh+acrOa6ouWHuueahOWIpOaWreadoeS7tlxyXG4gICAgICAgIGNvbnN0IGVsZVN0eWxlczogYW55ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgICAgICBjb25zdCBjbG9uZUVsZTogYW55ID0gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy50aVJlbmRlcmVyLnNldFN0eWxlcyhjbG9uZUVsZSwge1xyXG4gICAgICAgICAgICAvLyDmtonlj4rlhoXlrrnlrZfkvZPnmoTnm7jlhbPmoLflvI/lpITnkIZcclxuICAgICAgICAgICAgZm9udFNpemU6IGVsZVN0eWxlcy5mb250U2l6ZSxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogZWxlU3R5bGVzLmZvbnRXZWlnaHQsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IGVsZVN0eWxlcy5mb250RmFtaWx5LFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBlbGVTdHlsZXMucGFkZGluZyxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IGVsZVN0eWxlcy5wYWRkaW5nTGVmdCwgLy8g5aSE55CG5ZyoSUXlkozngavni5DkuIvojrflj5ZwYWRkaW5n5Li656m66Zeu6aKY77ya5Zyo54Gr54uQ5ZKMSUXkuIvlj6rog73nlKjlj6rog73nlKhwYWRkaW5nK1vmlrnkvY1d55qE5pa55byP5p2l6I635Y+W5YWD57Sg55qEcGFkZGluZ+WAvFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IGVsZVN0eWxlcy5wYWRkaW5nUmlnaHQsXHJcbiAgICAgICAgICAgIGJvcmRlcjogZWxlU3R5bGVzLmJvcmRlcixcclxuICAgICAgICAgICAgYm94U2l6aW5nOiBlbGVTdHlsZXMuYm94U2l6aW5nLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGVsZVN0eWxlcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIC8vIOa2ieWPiuWuveW6puW4g+WxgOeahOebuOWFs+agt+W8j+WkhOeQhlxyXG4gICAgICAgICAgICBtYXhXaWR0aDogJ25vbmUnLCAvLyDmuIXpmaTmnIDlpKflrr3luqbmoLflvI/vvIznoa7kv53lhoXlrrnlj6/mmL7npLrlrozlhahcclxuICAgICAgICAgICAgd2lkdGg6ICdhdXRvJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcclxuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIC8vIGRpc3BsYXkgYmxvY2vnmoTmg4XlhrXkuIvvvIzlhYPntKDniLblrrnlmajorr7nva5tYXJnaW7ml7bvvIzlr7zoh7Tlr7zoh7Rib2R55Y+Y5a6977yM5LuO6ICM5LiO5YWD57Sg5pys6Lqr5a695bqm5LiN5Yy56YWN77yM5Lya5a+86Ie05Y+v5pi+56S65a6M5YWo5L2G5Ye6dGlw55qE6Zeu6aKY77yM5Zug5q2k5q2k5aSE5pS55Y+Y5YW2ZGlzcGxheeaWueW8j1xyXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJywgLy8g5YWD57Sg6ZqQ6JeP5L2G5YGa5Y2g5L2N5aSE55CGXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJywgLy8g6YG/5YWN5YWL6ZqG5YWD57Sg5b2x5ZON6aG16Z2i6auY5bqm77yM5a+86Ie05Ye65rua5Yqo5p2hXHJcbiAgICAgICAgICAgIGxlZnQ6ICctOTk5OXB4JyxcclxuICAgICAgICAgICAgdG9wOiAnLTk5OTlweCdcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5ib2R5LCBjbG9uZUVsZSk7XHJcbiAgICAgICAgLy8g5L2/55SoZ2V0Qm91bmRpbmdDbGllbnRSZWN06ICM5LiN5L2/55SoZ2V0Q29tcHV0ZWRTdHlsZSzmmK/lm6DkuLpnZXRDb21wdXRlZFN0eWxl5ZyoXHJcbiAgICAgICAgLy8g5ZCE5rWP6KeI5Zmo6I635Y+W5Yiw55qE5a695bqm5LiN5LiA6Ie077yISUXkuIvlj5bliLDnmoTmmK/lhoXlrrnlrr3luqbvvIzogIzlnKhDaHJvbWXlkoxGRuS4i+WPluWIsOeahOaYr+aVtOS4quWFg+e0oOWuveW6pu+8ieOAglxyXG4gICAgICAgIC8vIElF5LiL6K6h566X57K+5bqm6auYKOWwj+aVsOeCueWQjjE15L2NKe+8jOWkmuaVsOS4reaWh+WSjOaVsOWtl+aIluiLseaWh+a3t+aOkueahOaWh+acrOiuoeeul+WHuuadpeeahCBtYXhXaWR0aCDlkowgdGV4dFdpZHRoXHJcbiAgICAgICAgLy8g55Sx5LqO57K+5bqm6auY6ICM5a+86Ie05pyJ5b6u5bCP5beu6Led77yM5LuO6ICM5b2x5ZON5LqGIGlzT3ZlcmZsb3cg55qE5Yik5pat57uT5p6c77yM5LuO5a6e6ZmF5rWL6K+V5b6X5p2l57uT6K6677ya5L+d55WZ5Lik5L2N5bCP5pWw6IO95aSf5L+d6K+B5Yik5pat57uT5p6c5pu05YeG56Gu5Lqb44CCXHJcbiAgICAgICAgY29uc3QgbWF4V2lkdGg6IG51bWJlciA9IHBhcnNlRmxvYXQoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxyXG4gICAgICAgICAgICAudG9GaXhlZCgyKSk7XHJcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoOiBudW1iZXIgPSBwYXJzZUZsb2F0KGNsb25lRWxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXHJcbiAgICAgICAgICAgIC50b0ZpeGVkKDIpKTtcclxuICAgICAgICAvLyDmraTlpITmsqHmnInkvb/nlKhhbmd1bGFy55qEUmVuZGVyZXIy5piv5Zug5Li6UmVuZGVyZXIyLnJlbW92ZUNoaWxk5b+F6aG75pyJ5Y+Y5YyW5qOA5rWL5omN6IO95ZyoZG9t5LiK55Sf5pWI77yMXHJcbiAgICAgICAgLy8g5q2k5aSE6ICD6JmR5Yiw5oCn6IO95LiN6Kem5Y+R5Y+Y5YyW5qOA5rWL77yM5omA5Lul6YCJ5oup5L2/55So5Y6f55Sf55qEcmVtb3ZlQ2hpbGTmlrnms5XjgIJcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNsb25lRWxlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHRXaWR0aCA+IG1heFdpZHRoO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVRpcChlbGVtZW50OiBFbGVtZW50LCBvcHRpb25zOiBUaU92ZXJmbG93Q29uZmlnKTogVGlUaXBSZWYge1xyXG4gICAgICAgIC8vIOaWh+acrOi2hemVv+aXtu+8jOaYvuekunRpcOaPkOekuu+8mlxyXG4gICAgICAgIC8vIHRpcOaYvuekuuS9jee9ruWFg+e0oOiuvue9ru+8mum7mOiupOS4umVsZW1lbnRcclxuICAgICAgICBjb25zdCBjb25maWc6IFRpT3ZlcmZsb3dDb25maWcgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGxldCBob3N0RWxlQ29uZmlnOiBhbnkgPSBjb25maWcudGlwRWxlbWVudDtcclxuICAgICAgICBpZiAodHlwZW9mIGhvc3RFbGVDb25maWcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgaG9zdEVsZUNvbmZpZyA9IGhvc3RFbGVDb25maWcoZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRpcEhvc3RFbGU6IEVsZW1lbnQgPSBob3N0RWxlQ29uZmlnIHx8IGVsZW1lbnQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRpcFNlcnZpY2UuY3JlYXRlKHRpcEhvc3RFbGUsIHtcclxuICAgICAgICAgICAgaG9zdEVsZVg6IGNvbmZpZy50aXBIb3N0RWxlWCxcclxuICAgICAgICAgICAgcG9zaXRpb246IGNvbmZpZy50aXBQb3NpdGlvbixcclxuICAgICAgICAgICAgbWF4V2lkdGg6IGNvbmZpZy50aXBNYXhXaWR0aCxcclxuICAgICAgICAgICAgdHJpZ2dlcjogJ21vdXNlJyxcclxuICAgICAgICAgICAgc2hvd0ZuOiAoKTogVGlUaXBTaG93SW5mbyA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aXBDb250ZW50IOS4uuepuiDmiJbogIUg5pyq5rqi5Ye65oOF5Ya15LiL77yM5LiN5pi+56S6dGlwXHJcbiAgICAgICAgICAgICAgICAvLyB0aXBQb3NpdGlvbuiuvue9ruS4um5vbmXmmK/ljrvpmaRTZWxlY3Tpu5jorqTotoXplb90aXDvvIzmlLnnlLF0ZW1wbGF0ZeWGheWuueiHquWumuS5iXRpcFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy50aXBQb3NpdGlvbiA9PT0gJ25vbmUnIHx8IGNvbmZpZy50aXBDb250ZW50ID09PSAnJyB8fCAhdGhpcy5pc092ZXJmbG93KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGlw5YaF5a656K6+572u77ya6buY6K6k5Li65YWD57Sg5Lit55qE5paH5pys5YaF5a65XHJcbiAgICAgICAgICAgICAgICBsZXQgdGlwQ29udGVudDogc3RyaW5nID0gY29uZmlnLnRpcENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc1VuZGVmaW5lZCh0aXBDb250ZW50KSkgeyAvLyBjb250ZW505Y+v6IO95Li6XCJcIu+8jOWboOatpOatpOWkhOWIpOaWrXVuZGVmaW5lZOiAjOS4jeS9v+eUqHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGlwQ29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29udGVudDogdGlwQ29udGVudCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIl19