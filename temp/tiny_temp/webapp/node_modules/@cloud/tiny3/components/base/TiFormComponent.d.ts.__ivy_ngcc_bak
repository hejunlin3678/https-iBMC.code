import { EventEmitter, SimpleChanges, Type } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { TiBaseComponent } from './TiBaseComponent';
/**
 * 表单基类，已实现autofocus tabindex disabled focus() blur() focus/blur/change事件 ControlValueAccessor
 */
export declare class TiFormComponent extends TiBaseComponent implements ControlValueAccessor {
    /**
     * HTML属性tabindex
     */
    tabindex: string;
    /**
     * 是否禁用
     */
    disabled: boolean;
    /**
     * HTML事件focus
     */
    readonly focusEvent: EventEmitter<FocusEvent>;
    /**
     * HTML事件blur
     */
    readonly blurEvent: EventEmitter<FocusEvent>;
    /**
     * @ignore
     * HTML事件change
     */
    readonly changeEvent: EventEmitter<any>;
    private focusCancelFns;
    private blurCancelFns;
    private mousedownCancelFns;
    private focusModel;
    protected focusElem: any;
    /**
     * 整体focus/blur事件参与的元素，和disabled设置。
     * 组件具有多个input输入框:
     * 1)无元素聚焦->任一元素聚焦=整体聚焦事件。
     * 2)任一元素失焦->其他元素无焦点=整体失焦事件。
     */
    private focusableElems;
    private _model;
    private ngAfterViewCheckedFirst;
    protected onModelChange: (model: any) => void;
    protected onModelTouched: () => void;
    protected focusedElem: any;
    /**
     * @ignore
     * 实现表单注册接口
     * @param type 类型
     * @returns 对象
     */
    static getValueAccessor(type: Type<any>): any;
    /**
     * 是否组件整体聚焦
     */
    get focused(): boolean;
    /**
     * 为Dom元素添加/移除属性，此处用于disabled和focused属性的操作
     * @param  element 需要操作的Dom元素
     * @param  attr 操作的属性
     * @param  value 属性值，为true时属性值即为属性值,为false时，移除属性
     */
    protected setAttr(element: any, attr: string, value: boolean): void;
    ngOnInit(): void;
    /**
     * 监听disabled变化
     */
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * 注意：子类继承自Form基类，如果有this.setFocusableElems([xxx]), 那么要更晚调用super.ngAfterViewChecked()。
     * 子类ngAfterViewChecked(): void {
     *      this.setFocusableElems([xxx]);
     *      // 更晚调用super
     *      super.ngAfterViewChecked();
     * }
     */
    ngAfterViewChecked(): void;
    /**
     * 当做生命周期用吧，监听模型值变化。包括writeValue和this.model=赋值 这两个时刻。
     * @param model 模型值
     */
    protected ngOnModelChange(model: any): void;
    /**
     * 设置tab键/点击时的聚焦元素，会顺便设置组件focus()聚焦时可聚焦元素（第一个非disabled的可聚焦元素）。
     * 当可聚焦元素变动，或者单一元素disabled状态变动，都要重新调用此方法设置。
     * 建议一般在ngOnInit生命周期调用，如果ngFor/ngIf内元素在ngOnInit找不到那么可在ngAfterViewInit生命周期调用。
     * 注意：所有生命周期，都要调用类似super.ngOnInit()
     *
     * @param elems 可聚焦元素数组Array<Element>，第一个非disabled元素为整个组件的可聚焦元素。
     *
     * 目前使用分为几种情况：
     * 1）一般表单组件，含有可聚焦子元素。
     * 组件主动设置可聚焦元素数组this.setFocusableElems([xxxElement, yyyElement]);
     * 2）有的表单组件，永远不聚焦。
     * slider/list/menulist/droplist，统一不调用此接口。
     * a.不调用接口时，@Input() tabindex: string = '0';未生效。但用户在html标签上设置的属性tabindex="0"等，会生效。
     * b.调用了this.setFocusableElems([]);时，强制清除了标签属性tabindex。用户设置的属性tabindex="1"，会无效，不出现在标签上。
     * 3）少量组件，内部没有可聚焦元素。但是皮儿需要聚焦，ti-dominator。
     * 需要设置this.setFocusableElems([this.nativeElement]);
     */
    protected setFocusableElems(elems: Array<any>): void;
    /**
     *  调用focus()函数，会触发组件整体聚焦，此时焦点元素。
     */
    private setFocusElem;
    /**
     * 去除皮上的tabindex，给内部可聚焦子元素添加tabindex
     * 当然，特殊情况：this.setFocusableElems([this.nativeElement]);时，又会给皮上补上tabindex
     * 本来此方法，可以合入setFocusEvents()，减少遍历循环。但为了清晰，依然单独为函数。
     */
    private setElemsTabindex;
    /**
     * @ignore
     */
    getFocusableElems(): Array<any>;
    /**
     * 宿主元素标签上添加类似原生focus()方法。
     * 用户调用方法: document.getElementById('ti-xxx').focus();
     * 其实，更推荐调用组件实例上的方法tiXxxComp.focus();
     */
    private setNativeElementFocusFn;
    /**
     * 设置组件中的可聚焦元素并监听事件
     */
    private setFocusEvents;
    /**
     * focus回调函数
     */
    private focusCallbackFn;
    /**
     * blur 回调函数
     */
    private blurCallbackFn;
    /**
     * 聚焦方法。类似HTML DOM节点方法focus
     */
    focus(): void;
    /**
     * 失焦方法。类似HTML DOM节点方法blur
     */
    blur(): void;
    /**
     * Tiny组件各种行为，尽量和原生一致。 autofocus也许可以做成一个指令
     * Tiny3新增：增加初始化焦点autofocus支持。IE9本来不支持autofocus，这时也支持了
     */
    private autoFocus;
    /**
     * 实现类表单组件的set和get方法
     */
    get model(): any;
    /**
     * 设置model值，如果有变化，则触发ngModelChange
     */
    set model(model: any);
    /**
     * @ignore
     * 如果用户改变了[ngModel]绑定的变量，那么Angular会通知到这里
     * 子类如果没有特殊需求，都需要首行调用super.writeValue（xxx）
     *
     * super.writeValue 和 this.model=xxx的区别：
     * super.writeValue不会触发ngModelChange
     * this.model=xxx会触发ngModelChange
     * @param model any类型
     */
    writeValue(model: any): void;
    /**
     * @ignore
     * Angular将(ngModelChange)绑定的函数，通知到这里。
     * 当组件内部model值改变，需要调用这个函数向外通知。
     * @param fn 回调函数
     */
    registerOnChange(fn: (model: any) => void): void;
    /**
     * @ignore
     * Blur时，或者需要校验时，需要调用此函数。（可能描述不准确，需要再查资料）
     * @param fn 回调函数
     */
    registerOnTouched(fn: () => void): void;
    /**
     * @ignore
     * 用户绑定在[disabled]上的变量变化，会通知到这里。
     * ti-xxx组件皮上设置[disabled]，会给皮上设置disabled属性，也会给所有可聚焦元素设置disabled属性。
     * 如有特殊需求，子类可以不使用super.setDisabledState(), 而是直接覆盖。
     * Angular原生[disabled]机制：checkbox/radio走不进原生setDisabledState()。原生[disabled][id]等取值也很晚。
     * 注意: Form基类@Input() disabled已经接管了Angular原生[disabled]机制。
     * ngOnChanges监听到disabled值（第一次和后续改变），会通知到这里。
     * @param isDisabled 是否禁用
     */
    setDisabledState?(isDisabled: boolean): void;
    /**
     * 设置tabindex
     * @param element 原生标签元素
     */
    private setTabindex;
}
/**
 * tabindex相关知识：
 * 所有已设置tabindex的元素，都会点击聚焦。哪怕<div tabindex="-1">test</div>也会点击聚焦。
 * Tab键，会按照顺序聚焦：1,2,3,4，...0，按照此顺序聚焦。
 * tabindex='-1'不参与Tab键, 但是可以点击聚焦。
 * A标签不设置tabindex效果：Chrome浏览器点击时无蓝框，tab时有蓝框。其他浏览器有差异。
 * A标签禁用时想要点击和tab都不落焦点，唯一方法是去除href
 * input标签不设置tabindex效果：Chrome浏览器点击时/tab时都有蓝框。
 * 如果设置tabindex='',或者tabindex='tabindex'，这样非法设置，Chrome相当于没有设置。其他浏览器有差异
 */
