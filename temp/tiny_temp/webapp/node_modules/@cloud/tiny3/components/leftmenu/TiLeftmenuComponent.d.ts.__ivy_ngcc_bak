import { ElementRef, EventEmitter, NgZone, Renderer2, SimpleChanges } from '@angular/core';
import { ActivatedRoute, NavigationExtras, Router } from '@angular/router';
import { TiBaseComponent } from '../base/TiBaseModule';
import { TiLeftmenuLevel1Component } from './TiLeftmenuLevel1Component';
import { TiRenderer } from '../../services/renderer/TiRenderer';
/**
 * 左侧菜单各项数据接口
 *
 * 是TiLeftmenuLevel1 和 TiLeftmenuLevel2 组件的 item 接口的数据类型
 */
export interface TiLeftmenuItem {
    /**
     * 设置当前菜单项对应的路由，与 Router.navigate方法的第一个参数一样
     */
    router?: Array<any>;
    /**
     * 设置当前菜单项对应路由的配置信息，与 Router.navigate方法的第二个参数一样
     */
    routerExtras?: NavigationExtras;
    /**
     * 设置一个router路由列表，当该列表中的路由被激活时，其对应的菜单项被激活处于高亮状态。
     * 其使用场景为多个路由对应同一个左侧菜单项。
     *
     * routerList 数组中每一个元素与 Router.navigate方法的第一个参数一样
     */
    routerList?: Array<Array<any>>;
    /**
     * 链接地址，点击后路由激活项不变，在新页面打开配置地址。
     *
     * 10.0.1新增
     *
     * v10.0.1 ~ v10.1.3版本存在XSS攻击(url类型)风险和用户点击这个链接并进入一个新的标签，新标签中的页面如果存在恶意代码，就可以将原网站直接导航到一个虚假网站的安全风险。
     *
     * v10.1.4 版本做了安全处理，已不存在上述两种安全问题，建议业务尽快升级版本。
     */
    href?: string;
    /**
     * 设置分界线（只支持一级菜单），在设置该属性菜单项的底部生成一条区块分界线。
     *
     * 10.0.2新增
     */
    showDividingLine?: boolean;
    /**
     * 允许有多余的属性字段
     */
    [propName: string]: any;
}
/**
 * TiLeftmenu组件提供了一种方便灵活实现页面布局左侧菜单的方式，支持两级菜单。
 *
 * 其内部包含5个组件:
 *
 * TiLeftmenu : 左侧菜单最外层的指令；
 *
 * TiLeftmenuGroup: 菜单分组指令；
 *
 * TileftmenuGroupItem：分组文本内容指令；
 *
 * TiLeftmenuHead : 菜单头部内容指令；
 *
 * TiLeftmenuLevel1 ：一级菜单指令；
 *
 * TiLeftmenuItem ：一级菜单文本内容指令；
 *
 * TiLeftmenuLevel2 ：二级菜单指令。
 *
 * <example-url>../tiny3demo/#/leftmenu/leftmenu-all</example-url>
 */
export declare class TiLeftmenuComponent extends TiBaseComponent {
    renderer2: Renderer2;
    private router;
    private activeRoute;
    private tiRenderer;
    private zone;
    private document;
    /**
     * 设置激活菜单项。这个值应该是 TiLeftmenuLevel1 和 TiLeftmenuLevel2 组件的 item 接口传入的值的集合中的一个(item)
     *
     * 此接口是双向绑定的，设置时中括号“[]”和圆括号“()”要同时使用
     */
    active: TiLeftmenuItem;
    /**
     * 激活菜单项改变时向外通知
     */
    readonly activeChange: EventEmitter<TiLeftmenuItem>;
    /**
     * 控制右侧内容区的刷新
     *
     * 注意：当重复点击当前激活菜单项时，需要刷新右侧内容区，为了实现此功能设置了该接口；
     * 该接口是双向绑定的，当重复点击当前激活菜单项时，reloadState的值会经历 true(上次的值) -> false -> true
     * 的变化过程，开发者给改接口与其右侧区域容器上ngIf接口绑定的是同一个变量，所以ngIf的值也会经历同样的变化，
     * 从而做到右侧内容区的刷新。
     */
    reloadState: boolean;
    /**
     * 右侧内容区是否需要刷新的状态值改变时向外通知
     */
    readonly reloadStateChange: EventEmitter<boolean>;
    /**
     * 10.0.1新增
     *
     * 设置是否使用路由来控制菜单对应内容显示/隐藏，默认使用路由。
     */
    routable: boolean;
    /**
     * 是否开启左侧菜单面板可折叠功能，默认开启。
     */
    toggleable: boolean;
    /**
     * 左侧菜单面板是否为收起状态，用于设置面板收起/展开状态，默认展开。
     */
    collapsed: boolean;
    /**
     * 左侧菜单面板收起/展开状态改变时向外通知
     */
    readonly collapsedChange: EventEmitter<boolean>;
    /**
     * @ignore
     * tiLeftmenu中包含的 TiLeftmenuLevel1Component 实例集合
     */
    level1Items: Array<TiLeftmenuLevel1Component>;
    private navigationSubscription;
    /**
     * @ignore
     */
    readonly resolvedPromise: Promise<any>;
    /**
     * 标志量，是否为url改变(需要去改变active)
     */
    private isUrlChange;
    /**
     * @ignore
     */
    private panelContainer;
    /**
     * 滚动条的宽度, 在 TiLeftmenuFoot中也有使用
     * @ignore
     */
    scrollWidth: number;
    constructor(elementRef: ElementRef, renderer2: Renderer2, router: Router, activeRoute: ActivatedRoute, tiRenderer: TiRenderer, zone: NgZone, document: any);
    private static isDefaultActiveChildRoute;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    /**
     * @ignore
     * 模板中使用
     */
    toggleClickFn(): void;
    private getActiveItemByUrl;
    private isActived;
    private isMatchCurrentUrl;
    private link;
    /**
     * @ignore
     */
    navigate(item: TiLeftmenuItem): void;
    /**
     * @ignore
     * 点击当前选中项时，触发内容区重载
     * @param item 当前点击项
     */
    triggerReload(item: TiLeftmenuItem): void;
    private getNavigationExtras;
    private getRelativeRoute;
    /**
 * 得到浏览器滚动条的宽度和高度
 * 代表滚动条的方向，取值为X or Y
 */
    private getScrollbarSize;
}
