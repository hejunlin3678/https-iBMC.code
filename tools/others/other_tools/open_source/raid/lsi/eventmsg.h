/*
 * EVENTMSG.H - Header file for Event message definition
 *
 * Copyright (C) LSI Logic Corporation, 2004
 * Written by Gerry Smith
 */
#ifndef INCLUDE_EVENTMSG
#define INCLUDE_EVENTMSG

/*
 * define the event message strings
 *
 * Each entry in this array must correspond 1:1 with the MR_EVT entries defined in event.h
 */
typedef struct _MR_EVT_DESCRIPTION {
    MR_EVT      code;       // event code
    U16         locale;     // event locale (MR_EVT_LOCALE)
    S8          eventClass; // event class (MR_EVT_CLASS)
    U8          oobLocale;  // event OOB localae (MR_EVT_OOB_LOCALE)
    U32         argType;    // event argument type (MR_EVT_ARGS)
    const char  *desc;      // description
} MR_EVT_DESCRIPTION;

/*
 * define the event detail structure
 */
#ifdef EVT_DESCRIPTION_DEFINE                   // used to conditionally enable event detail definition
#define EV(str)     MR_EVT_##str                // short-hand reference to MR_EVT_*
#define EC(str)     MR_EVT_CLASS_##str          // short-hand reference to MR_EVT_CLASS_*
#define EL(str)     MR_EVT_LOCALE_##str         // short-hand reference to MR_EVT_LOCALE_*
#define EA(str)     MR_EVT_ARGS_##str           // argument type

#define EC_DBG      MR_EVT_CLASS_DEBUG
#define EC_P        MR_EVT_CLASS_PROGRESS
#define EC_I        MR_EVT_CLASS_INFO
#define EC_W        MR_EVT_CLASS_WARNING
#define EC_C        MR_EVT_CLASS_CRITICAL
#define EC_F        MR_EVT_CLASS_FATAL
#define EC_D        MR_EVT_CLASS_DEAD

#define ECB_I       MR_EVT_OOB_LOCALE_INVENTORY
#define ECB_H       MR_EVT_OOB_LOCALE_HWR
#define ECB_B       MR_EVT_OOB_LOCALE_MISC_BASIC
#define ECB_M1      MR_EVT_OOB_LOCALE_MISC_SET1
#define ECB_M2      MR_EVT_OOB_LOCALE_MISC_SET2
#define ECB_N       MR_EVT_OOB_LOCALE_NEVER

/*
 * define the event detail info
 */
MR_EVT_DESCRIPTION  EventDescription[] = {
{ EV(BOOT),                                 EL(CTRL),   EC_I,   0,    EA(PCI),    "Firmware initialization started (PCI ID %04x/%04x/%04x/%04x)" },
{ EV(VERSION),                              EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Firmware version %s" },
{ EV(BBU_TBBU_DIRTY_CACHE_CONFIG_MISMATCH), EL(BBU)+EL(CONFIG),EC_F,0,EA(NONE),   "Unable to recover cache data from TBBU" },
{ EV(BBU_TBBU_DIRTY_CACHE_PROCESSED),       EL(BBU),    EC_I,   0,    EA(NONE),   "Cache data recovered from TBBU successfully" },
{ EV(CFG_CLEARED),                          EL(CONFIG), EC_I,   0,    EA(NONE),   "Configuration cleared" },
{ EV(CLUST_DOWN),                           EL(CLUSTER),EC_W,   0,    EA(NONE),   "Cluster down; communication with peer lost" },
{ EV(CLUST_OWNERSHIP_CHANGE),               EL(CLUSTER),EC_I,   0,    EA(LD_OWNER),"%s ownership changed from %02x to %02x" },
{ EV(CTRL_ALARM_DISABLED),                  EL(CTRL),   EC_I,   0,    EA(NONE),   "Alarm disabled by user" },
{ EV(CTRL_ALARM_ENABLED),                   EL(CTRL),   EC_I,   0,    EA(NONE),   "Alarm enabled by user" },
{ EV(CTRL_BGI_RATE_CHANGED),                EL(CTRL),   EC_I,   0,    EA(RATE),   "Background initialization rate changed to %d%%" },
{ EV(CTRL_CACHE_DISCARDED),                 EL(CTRL),   EC_F,   0,    EA(NONE),   "Controller cache discarded due to memory/battery problems" },
{ EV(CTRL_CACHE_REBOOT_CANT_RECOVER),       EL(CTRL)+EL(CONFIG),EC_F,0,EA(NONE),  "Unable to recover cache data due to configuration mismatch" },
{ EV(CTRL_CACHE_REBOOT_RECOVER),            EL(CTRL),   EC_I,   0,    EA(NONE),   "Cache data recovered successfully" },
{ EV(CTRL_CACHE_VERSION_MISMATCH),          EL(CTRL),   EC_F,   0,    EA(NONE),   "Controller cache discarded due to firmware version incompatibility" },
{ EV(CTRL_CC_RATE_CHANGED),                 EL(CTRL),   EC_I,   0,    EA(RATE),   "Consistency Check rate changed to %d%%" },
{ EV(CTRL_CRASH),                           EL(CTRL),   EC_D,   0,    EA(STR),    "Fatal firmware error: %s" },
{ EV(CTRL_FACTORY_DEFAULTS),                EL(CTRL),   EC_I,   0,    EA(NONE),   "Factory defaults restored" },
{ EV(CTRL_FLASH_BAD_IMAGE),                 EL(CTRL),   EC_W,   0,    EA(NONE),   "Flash downloaded image corrupt" },
{ EV(CTRL_FLASH_ERASE_ERROR),               EL(CTRL),   EC_C,   0,    EA(NONE),   "Flash erase error" },
{ EV(CTRL_FLASH_ERASE_TIMEOUT),             EL(CTRL),   EC_C,   0,    EA(NONE),   "Flash timeout during erase" },
{ EV(CTRL_FLASH_GENERAL_ERROR),             EL(CTRL),   EC_C,   0,    EA(NONE),   "Flash error" },
{ EV(CTRL_FLASH_IMAGE),                     EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Flashing image: %s" },
{ EV(CTRL_FLASH_OK),                        EL(CTRL),   EC_I,   0,    EA(NONE),   "Flash of new firmware image(s)complete" },
{ EV(CTRL_FLASH_PROGRAM_ERROR),             EL(CTRL),   EC_C,   0,    EA(NONE),   "Flash programming error" },
{ EV(CTRL_FLASH_PROGRAM_TIMEOUT),           EL(CTRL),   EC_C,   0,    EA(NONE),   "Flash timeout during programming" },
{ EV(CTRL_FLASH_UNKNOWN_CHIP_TYPE),         EL(CTRL),   EC_C,   0,    EA(NONE),   "Flash chip type unknown" },
{ EV(CTRL_FLASH_UNKNOWN_CMD_SET),           EL(CTRL),   EC_C,   0,    EA(NONE),   "Flash command set unknown" },
{ EV(CTRL_FLASH_VERIFY_FAILURE),            EL(CTRL),   EC_C,   0,    EA(NONE),   "Flash verify failure" },
{ EV(CTRL_FLUSH_RATE_CHANGED),              EL(CTRL),   EC_I,   0,    EA(RATE),   "Flush rate changed to %d seconds" },
{ EV(CTRL_HIBERNATE),                       EL(CTRL),   EC_I,   0,    EA(NONE),   "Hibernate command received from host" },
{ EV(CTRL_LOG_CLEARED),                     EL(CTRL),   EC_I,   0,    EA(NONE),   "Event log cleared" },
{ EV(CTRL_LOG_WRAPPED),                     EL(CTRL),   EC_I,   0,    EA(NONE),   "Event log wrapped" },
{ EV(CTRL_MEM_ECC_MULTI_BIT),               EL(CTRL),   EC_D,   0,    EA(ECC),    "Multi-bit ECC error: ECAR=%x, ELOG=%x, (%s)" },
{ EV(CTRL_MEM_ECC_SINGLE_BIT),              EL(CTRL),   EC_W,   ECB_H,EA(ECC),    "Single-bit ECC error: ECAR=%x, ELOG=%x, (%s)" },
{ EV(CTRL_NOT_ENOUGH_MEMORY),               EL(CTRL),   EC_D,   0,    EA(NONE),   "Not enough controller memory" },
{ EV(CTRL_PR_DONE),                         EL(CTRL),   EC_I,   ECB_B,EA(NONE),   "Patrol Read complete" },
{ EV(CTRL_PR_PAUSE),                        EL(CTRL),   EC_I,   0,    EA(NONE),   "Patrol Read paused" },
{ EV(CTRL_PR_RATE_CHANGED),                 EL(CTRL),   EC_I,   0,    EA(RATE),   "Patrol Read Rate changed to %d%%" },
{ EV(CTRL_PR_RESUME),                       EL(CTRL),   EC_I,   ECB_B,EA(NONE),   "Patrol Read resumed" },
{ EV(CTRL_PR_START),                        EL(CTRL),   EC_I,   ECB_B,EA(NONE),   "Patrol Read started" },
{ EV(CTRL_REBUILD_RATE_CHANGED),            EL(CTRL),   EC_I,   0,    EA(RATE),   "Rebuild rate changed to %d%%" },
{ EV(CTRL_RECON_RATE_CHANGED),              EL(CTRL),   EC_I,   0,    EA(RATE),   "Reconstruction rate changed to %d%%" },
{ EV(CTRL_SHUTDOWN),                        EL(CTRL),   EC_I,   0,    EA(NONE),   "Shutdown command received from host" },
{ EV(CTRL_TEST),                            EL(CTRL),   EC_I,   0,    EA(STR),    "Test event: '%s'" },
{ EV(CTRL_TIME_SET),                        EL(CTRL),   EC_I,   0,    EA(TIME),   "Time established as %s; (%d seconds since power on)" },
{ EV(CTRL_USER_ENTERED_DEBUGGER),           EL(CTRL),   EC_I,   0,    EA(NONE),   "User entered firmware debugger" },
{ EV(LD_BGI_ABORTED),                       EL(LD),     EC_W,   ECB_B,EA(LD),     "Background Initialization aborted on %s" },
{ EV(LD_BGI_CORRECTED_MEDIUM_ERROR),        EL(LD),     EC_I,   0,    EA(LD_LBA_PD_LBA),"Background Initialization corrected medium error (%s at %llx, %s at %llx)" },
{ EV(LD_BGI_DONE),                          EL(LD),     EC_I,   ECB_B,EA(LD),     "Background Initialization completed on %s" },
{ EV(LD_BGI_DONE_ERRORS),                   EL(LD),     EC_F,   0,    EA(LD),     "Background Initialization completed with uncorrectable errors on %s" },
{ EV(LD_BGI_DOUBLE_MEDIUM_ERRORS),          EL(LD),     EC_F,   0,    EA(PD_LBA_LD),"Background Initialization detected uncorrectable multiple medium errors (%s at %llx on %s)" },
{ EV(LD_BGI_FAILED),                        EL(LD),     EC_C,   0,    EA(LD),     "Background Initialization failed on %s" },
{ EV(LD_BGI_PROGRESS),                      EL(LD),     EC_P,   0,    EA(LD_PROG),"Background Initialization progress on %s is %s" },
{ EV(LD_BGI_START),                         EL(LD),     EC_I,   ECB_B,EA(LD),     "Background Initialization started on %s" },
{ EV(LD_CACHE_POLICY_CHANGE),               EL(LD),     EC_I,   ECB_N,EA(LD_PROP),"Policy change on %s to %s from %s", },
{ EV(OBSOLETE_1),                           0,          0,      0,    EA(NONE),   "OBSOLETE", },
{ EV(LD_CC_ABORTED),                        EL(LD),     EC_I,   ECB_B,EA(LD),     "Consistency Check aborted on %s" },
{ EV(LD_CC_CORRECTED_MEDIUM_ERROR),         EL(LD),     EC_I,   0,    EA(LD_LBA_PD_LBA),"Consistency Check corrected medium error (%s at %llx, %s at %llx)" },
{ EV(LD_CC_DONE),                           EL(LD),     EC_I,   ECB_B,EA(LD),     "Consistency Check done on %s" },
{ EV(LD_CC_DONE_INCON),                     EL(LD),     EC_I,   ECB_B,EA(LD_COUNT),"Consistency Check done with corrections on %s, (corrections=%d)" },
{ EV(LD_CC_DOUBLE_MEDIUM_ERRORS),           EL(LD),     EC_F,   0,    EA(PD_LBA_LD),"Consistency Check detected uncorrectable multiple medium errors (%s at %llx on %s)" },
{ EV(LD_CC_FAILED),                         EL(LD),     EC_C,   0,    EA(LD),     "Consistency Check failed on %s" },
{ EV(LD_CC_FAILED_UNCOR),                   EL(LD),     EC_F,   0,    EA(LD),     "Consistency Check completed with uncorrectable errors on %s" },
{ EV(LD_CC_INCONSISTENT_PARITY),            EL(LD),     EC_I,   0,    EA(LD_STRIP),"Consistency Check found inconsistent parity on %s at strip %llx" },
{ EV(LD_CC_INCONSISTENT_PARITY_LOGGING_DISABLED),EL(LD),EC_W,   0,    EA(LD),     "Consistency Check inconsistency logging disabled on %s (too many inconsistencies)" },
{ EV(LD_CC_PROGRESS),                       EL(LD),     EC_P,   0,    EA(LD_PROG),"Consistency Check progress on %s is %s" },
{ EV(LD_CC_START),                          EL(LD),     EC_I,   ECB_B,EA(LD),     "Consistency Check started on %s" },
{ EV(LD_INIT_ABORTED),                      EL(LD),     EC_I,   ECB_B,EA(LD),     "Initialization aborted on %s" },
{ EV(LD_INIT_FAILED),                       EL(LD),     EC_C,   0,    EA(LD),     "Initialization failed on %s" },
{ EV(LD_INIT_PROGRESS),                     EL(LD),     EC_P,   0,    EA(LD_PROG),"Initialization progress on %s is %s" },
{ EV(LD_INIT_START_FAST),                   EL(LD),     EC_I,   ECB_B,EA(LD),     "Fast initialization started on %s" },
{ EV(LD_INIT_START_FULL),                   EL(LD),     EC_I,   ECB_B,EA(LD),     "Full initialization started on %s" },
{ EV(LD_INIT_SUCCESSFUL),                   EL(LD),     EC_I,   ECB_B,EA(LD),     "Initialization complete on %s" },
{ EV(LD_PROP_CHANGE),                       EL(LD),     EC_I,   0,    EA(LD_PROP),"%s Properties updated to %s" },
{ EV(LD_RECON_DONE),                        EL(LD),     EC_I,   ECB_B,EA(LD),     "Reconstruction complete on %s" },
{ EV(LD_RECON_DONE_ERRORS),                 EL(LD),     EC_F,   0,    EA(LD),     "Reconstruction of %s stopped due to unrecoverable errors" },
{ EV(LD_RECON_DOUBLE_MEDIUM_ERRORS),        EL(LD),     EC_F,   0,    EA(LD_LBA_PD_LBA),"Reconstruct detected uncorrectable multiple medium errors (%s at %llx on %s at %llx)" },
{ EV(LD_RECON_PROGRESS),                    EL(LD),     EC_P,   0,    EA(LD_PROG),"Reconstruction progress on %s is %s" },
{ EV(LD_RECON_RESUME),                      EL(LD),     EC_I,   0,    EA(LD),     "Reconstruction resumed on %s" },
{ EV(LD_RECON_RESUME_FAILED),               EL(LD)+EL(CONFIG),EC_F,0, EA(LD),     "Reconstruction resume of %s failed due to configuration mismatch" },
{ EV(LD_RECON_START),                       EL(LD),     EC_I,   ECB_B,EA(LD),     "Reconstruction started on %s" },
{ EV(LD_STATE_CHANGE),                      EL(LD),     EC_I,   ECB_N,EA(LD_STATE),"State change on %s from %s to %s" },
{ EV(PD_CLEAR_ABORTED),                     EL(PD),     EC_I,   ECB_B,EA(PD),     "Clear aborted on %s" },
{ EV(PD_CLEAR_FAILED),                      EL(PD),     EC_C,   0,    EA(PD_ERR), "Clear failed on %s (Error %02x)" },
{ EV(PD_CLEAR_PROGRESS),                    EL(PD),     EC_P,   0,    EA(PD_PROG),"Clear progress on %s is %s" },
{ EV(PD_CLEAR_STARTED),                     EL(PD),     EC_I,   ECB_B,EA(PD),     "Clear started on %s" },
{ EV(PD_CLEAR_SUCCESSFUL),                  EL(PD),     EC_I,   ECB_B,EA(PD),     "Clear completed on %s" },
{ EV(PD_ERR),                               EL(PD),     EC_I,   0,    EA(PD_ERR), "Error on %s (Error %02x)" },
{ EV(PD_FORMAT_COMPLETE),                   EL(PD),     EC_I,   ECB_B,EA(PD),     "Format complete on %s" },
{ EV(PD_FORMAT_STARTED),                    EL(PD),     EC_I,   ECB_B,EA(PD),     "Format started on %s" },
{ EV(PD_HS_SMART_POLL_FAILED),              EL(PD),     EC_W,   ECB_B,EA(PD_ERR), "Hot Spare SMART polling failed on %s (Error %02x)" },
{ EV(PD_INSERTED),                          EL(PD),     EC_I,   ECB_N,EA(PD),     "Inserted: %s" },
{ EV(PD_NOT_SUPPORTED),                     EL(PD),     EC_W,   0,    EA(PD),     "%s is not supported" },
{ EV(PD_PR_CORRECTED),                      EL(PD),     EC_I,   0,    EA(PD_LBA), "Patrol Read corrected medium error on %s at %llx" },
{ EV(PD_PR_PROGRESS),                       EL(PD),     EC_P,   0,    EA(PD_PROG),"Patrol Read progress on %s is %s" },
{ EV(PD_PR_UNCORRECTABLE),                  EL(PD),     EC_F,   0,    EA(PD_LBA), "Patrol Read found an uncorrectable medium error on %s at %llx" },
{ EV(PD_PREDICTIVE_THRESHOLD_EXCEEDED),     EL(PD),     EC_W,   ECB_N,EA(PD),     "Predictive failure: %s" },
{ EV(PD_PUNCTURE),                          EL(PD),     EC_F,   0,    EA(PD_LBA), "Puncturing bad block on %s at %llx" },
{ EV(PD_RBLD_ABORT_BY_USER),                EL(PD),     EC_I,   ECB_B,EA(PD),     "Rebuild aborted by user on %s" },
{ EV(PD_RBLD_DONE_LD),                      EL(PD),     EC_I,   ECB_B,EA(LD),     "Rebuild complete on %s" },
{ EV(PD_RBLD_DONE_PD),                      EL(PD),     EC_I,   ECB_B,EA(PD),     "Rebuild complete on %s" },
{ EV(PD_RBLD_FAILED_BAD_SOURCE),            EL(PD),     EC_C,   0,    EA(PD),     "Rebuild failed on %s due to source drive error" },
{ EV(PD_RBLD_FAILED_BAD_TARGET),            EL(PD),     EC_C,   0,    EA(PD),     "Rebuild failed on %s due to target drive error" },
{ EV(PD_RBLD_PROGRESS),                     EL(PD),     EC_P,   0,    EA(PD_PROG),"Rebuild progress on %s is %s" },
{ EV(PD_RBLD_RESUME),                       EL(PD),     EC_I,   0,    EA(PD),     "Rebuild resumed on %s" },
{ EV(PD_RBLD_START),                        EL(PD),     EC_I,   ECB_B,EA(PD),     "Rebuild started on %s" },
{ EV(PD_RBLD_START_AUTO),                   EL(PD),     EC_I,   ECB_B,EA(PD),     "Rebuild automatically started on %s" },
{ EV(PD_RBLD_STOP_BY_OWNERSHIP_LOSS),       EL(PD),     EC_C,   0,    EA(PD),     "Rebuild stopped on %s due to loss of cluster ownerhsip" },
{ EV(PD_REASSIGN_WRITE_FAILED),             EL(PD),     EC_F,   0,    EA(PD_LBA), "Reassign write operation failed on %s at %llx" },
{ EV(PD_REBUILD_MEDIUM_ERROR),              EL(PD),     EC_F,   0,    EA(PD_LBA), "Unrecoverable medium error during rebuild on %s at %llx" },
{ EV(PD_REC_CORRECTING),                    EL(PD),     EC_I,   0,    EA(PD_LBA), "Corrected medium error during recovery on %s at %llx" },
{ EV(PD_RECOVER_MEDIUM_ERROR),              EL(PD),     EC_F,   0,    EA(PD_LBA), "Unrecoverable medium error during recovery on %s at %llx" },
{ EV(PD_REMOVED),                           EL(PD),     EC_W,   ECB_N,EA(PD),     "Removed: %s" },
{ EV(PD_SENSE),                             EL(PD),     EC_I,   0,    EA(CDB_SENSE),"Unexpected sense: %s, CDB:%s, Sense:%s" },
{ EV(PD_STATE_CHANGE),                      EL(PD),     EC_I,   ECB_N,EA(PD_STATE),"State change on %s from %s to %s" },
{ EV(PD_STATE_CHANGE_BY_USER),              EL(PD),     EC_I,   ECB_B,EA(PD_STATE),"State change by user on %s from %s to %s" },
{ EV(PD_REDUNDANT_PATH_BROKEN),             EL(PD)+EL(SAS),EC_W,0,    EA(PD),     "Redundant path to %s broken" },
{ EV(PD_REDUNDANT_PATH_RESTORED),           EL(PD)+EL(SAS),EC_I,0,    EA(PD),     "Redundant path to %s restored" },
{ EV(PD_DEDICATED_SPARE_NO_LONGER_USEFUL),  EL(PD)+EL(CONFIG),EC_I,ECB_B,EA(PD),  "Dedicated Hot Spare %s no longer useful due to deleted array" },
{ EV(SAS_TOPOLOGY_LOOP_DETECTED),           EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: Loop detected" },
{ EV(SAS_TOPOLOGY_UNADDRESSABLE_DEVICE),    EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: Unaddressable device" },
{ EV(SAS_TOPOLOGY_MULTIPLE_PORTS_TO_SAME_ADDR),EL(SAS), EC_C,   0,    EA(NONE),   "SAS topology error: Multiple ports to the same SAS address" },
{ EV(SAS_TOPOLOGY_EXPANDER_ERR),            EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: Expander error" },
{ EV(SAS_TOPOLOGY_SMP_TIMEOUT),             EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: SMP timeout" },
{ EV(SAS_TOPOLOGY_OUT_OF_ROUTE_ENTRIES),    EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: Out of route entries" },
{ EV(SAS_TOPOLOGY_INDEX_NOT_FOUND),         EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: Index not found" },
{ EV(SAS_TOPOLOGY_SMP_FUNCTION_FAILED),     EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: SMP function failed" },
{ EV(SAS_TOPOLOGY_SMP_CRC_ERROR),           EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: SMP CRC error" },
{ EV(SAS_TOPOLOGY_MULITPLE_SUBTRACTIVE),    EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: Multiple subtractive" },
{ EV(SAS_TOPOLOGY_TABLE_TO_TABLE),          EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: Table to table" },
{ EV(SAS_TOPOLOGY_MULTIPLE_PATHS),          EL(SAS),    EC_C,   0,    EA(NONE),   "SAS topology error: Multiple paths" },
{ EV(PD_UNUSABLE),                          EL(PD),     EC_F,   0,    EA(PD),     "Unable to access device %s" },
{ EV(PD_SPARE_DEDICATED_CREATED),           EL(PD)+EL(CONFIG),EC_I,ECB_B,EA(PD_SPARE), "Dedicated Hot Spare created on %s (%s)" },
{ EV(PD_SPARE_DEDICATED_DISABLED),          EL(PD)+EL(CONFIG),EC_I,ECB_B,EA(PD_SPARE),  "Dedicated Hot Spare %s (%s) disabled" },
{ EV(PD_SPARE_DEDICATED_NOT_USEFUL_FOR_ALL_ARRAYS),
                                            EL(PD)+EL(CONFIG),EC_W,ECB_B,EA(PD),  "Dedicated Hot Spare %s no longer useful for all arrays" },
{ EV(PD_SPARE_GLOBAL_CREATED),              EL(PD)+EL(CONFIG),EC_I,ECB_B,EA(PD_SPARE), "Global Hot Spare created on %s (%s)" },
{ EV(PD_SPARE_GLOBAL_DISABLED),             EL(PD)+EL(CONFIG),EC_I,ECB_B,EA(PD_SPARE),  "Global Hot Spare %s (%s) disabled" },
{ EV(PD_SPARE_GLOBAL_NOT_COVERING_ALL_ARRAYS),
                                            EL(PD)+EL(CONFIG),EC_W,ECB_B,EA(PD),  "Global Hot Spare %s does not cover all arrays" },
{ EV(LD_CREATED),                           EL(LD)+EL(CONFIG),EC_I,ECB_B,EA(LD),  "Created %s"},
{ EV(LD_DELETED),                           EL(LD)+EL(CONFIG),EC_I,ECB_B,EA(LD),  "Deleted %s"},
{ EV(LD_INCONSISTENT_DUE_AT_STARTUP),       EL(LD),     EC_I,   0,    EA(LD),     "Marking %s inconsistent due to active writes at shutdown" },
{ EV(BBU_PRESENT),                          EL(BBU),    EC_I,   ECB_I,EA(NONE),   "Battery Present" },
{ EV(BBU_NOT_PRESENT),                      EL(BBU),    EC_W,   ECB_I,EA(NONE),   "Battery Not Present" },
{ EV(BBU_NEW_BATTERY_DETECTED),             EL(BBU),    EC_I,   ECB_I,EA(NONE),   "New Battery Detected" },
{ EV(BBU_REPLACED),                         EL(BBU),    EC_I,   ECB_I,EA(NONE),   "Battery has been replaced" },
{ EV(BBU_TEMPERATURE_HIGH),                 EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Battery temperature is high" },
{ EV(BBU_VOLTAGE_LOW),                      EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Battery voltage low" },
{ EV(BBU_CHARGING),                         EL(BBU),    EC_I,   0,    EA(NONE),   "Battery started charging" },
{ EV(BBU_DISCHARGING),                      EL(BBU),    EC_I,   0,    EA(NONE),   "Battery is discharging" },
{ EV(BBU_TEMPERATURE_NORMAL),               EL(BBU),    EC_I,   ECB_H,EA(NONE),   "Battery temperature is normal" },
{ EV(BBU_REPLACEMENT_NEEDED_SOH_BAD),       EL(BBU),    EC_F,   0,    EA(NONE),   "Battery has failed and cannot support data retention. Please replace the battery" },
{ EV(BBU_RELEARN_STARTED),                  EL(BBU),    EC_I,   ECB_B,EA(NONE),   "Battery relearn started" },
{ EV(BBU_RELEARN_IN_PROGRESS),              EL(BBU),    EC_I,   0,    EA(NONE),   "Battery relearn in progress" },
{ EV(BBU_RELEARN_COMPLETE),                 EL(BBU),    EC_I,   ECB_B,EA(NONE),   "Battery relearn completed" },
{ EV(BBU_RELEARN_TIMEOUT),                  EL(BBU),    EC_W,   0,    EA(NONE),   "Battery relearn timed out" },
{ EV(BBU_RELEARN_PENDING),                  EL(BBU),    EC_I,   ECB_B,EA(NONE),   "Battery relearn pending: Battery is under charge" },
{ EV(BBU_RELEARN_POSTPONED),                EL(BBU),    EC_I,   0,    EA(NONE),   "Battery relearn postponed" },
{ EV(BBU_RELEARN_WILL_START_IN_4_DAYS),     EL(BBU),    EC_I,   0,    EA(NONE),   "Battery relearn will start in 4 days" },
{ EV(BBU_RELEARN_WILL_START_IN_2_DAYS),     EL(BBU),    EC_I,   0,    EA(NONE),   "Battery relearn will start in 2 day" },
{ EV(BBU_RELEARN_WILL_START_IN_1_DAYS),     EL(BBU),    EC_I,   0,    EA(NONE),   "Battery relearn will start in 1 day" },
{ EV(BBU_RELEARN_WILL_START_IN_5_HOURS),    EL(BBU),    EC_I,   ECB_B,EA(NONE),   "Battery relearn will start in 5 hours" },
{ EV(BBU_BATTERY_REMOVED),                  EL(BBU),    EC_W,   ECB_I,EA(NONE),   "Battery removed" },
{ EV(BBU_BATTERY_CAP_BELOW_SOH_THRESHOLD),  EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Current capacity of the battery is below threshold" },
{ EV(BBU_BATTERY_CAP_ABOVE_SOH_THRESHOLD),  EL(BBU),    EC_I,   ECB_H,EA(NONE),   "Current capacity of the battery is above threshold" },
{ EV(ENCL_DISCOVERED_SES),                  EL(ENCL),   EC_I,   0,    EA(PD),     "Enclosure (SES) discovered on %s" },
{ EV(ENCL_DISCOVERED_SAFTE),                EL(ENCL),   EC_I,   0,    EA(PD),     "Enclosure (SAF-TE) discovered on %s" },
{ EV(ENCL_COMMUNICATION_LOST),              EL(ENCL),   EC_C,   0,    EA(PD),     "Enclosure %s communication lost" },
{ EV(ENCL_COMMUNICATION_RESTORED),          EL(ENCL),   EC_I,   ECB_H,EA(PD),     "Enclosure %s communication restored" },
{ EV(ENCL_FAN_FAILED),                      EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s fan %d failed" },
{ EV(ENCL_FAN_INSERTED),                    EL(ENCL),   EC_I,   ECB_I,EA(PD_INDEX),"Enclosure %s fan %d inserted" },
{ EV(ENCL_FAN_REMOVED),                     EL(ENCL),   EC_W,   ECB_I,EA(PD_INDEX),"Enclosure %s fan %d removed" },
{ EV(ENCL_POWER_FAILED),                    EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s power supply %d failed" },
{ EV(ENCL_POWER_INSERTED),                  EL(ENCL),   EC_I,   ECB_I,EA(PD_INDEX),"Enclosure %s power supply %d inserted" },
{ EV(ENCL_POWER_REMOVED),                   EL(ENCL),   EC_W,   ECB_I,EA(PD_INDEX),"Enclosure %s power supply %d removed" },
{ EV(ENCL_SIM_FAILED),                      EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s EMM %d failed" },
{ EV(ENCL_SIM_INSERTED),                    EL(ENCL),   EC_I,   ECB_I,EA(PD_INDEX),"Enclosure %s EMM %d inserted" },
{ EV(ENCL_SIM_REMOVED),                     EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s EMM %d removed" },
{ EV(ENCL_TEMPERATURE_BELOW_WARNING),       EL(ENCL),   EC_W,   ECB_H,EA(PD_INDEX),"Enclosure %s temperature sensor %d below warning threshold" },
{ EV(ENCL_TEMPERATURE_BELOW_ERROR),         EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s temperature sensor %d below error threshold" },
{ EV(ENCL_TEMPERATURE_ABOVE_WARNING),       EL(ENCL),   EC_W,   ECB_H,EA(PD_INDEX),"Enclosure %s temperature sensor %d above warning threshold" },
{ EV(ENCL_TEMPERATURE_ABOVE_ERROR),         EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s temperature sensor %d above error threshold" },
{ EV(ENCL_SHUTDOWN),                        EL(ENCL),   EC_C,   0,    EA(PD),     "Enclosure %s shutdown" },
{ EV(ENCL_MAX_PER_PORT_EXCEEDED),           EL(ENCL),   EC_W,   ECB_H,EA(PD),     "Enclosure %s not supported; too many enclosures connected to port" },
{ EV(ENCL_FIRMWARE_MISMATCH),               EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s firmware mismatch (EMM %d)" },
{ EV(ENCL_BAD_SENSOR),                      EL(ENCL),   EC_W,   ECB_H,EA(PD_INDEX),"Enclosure %s sensor %d bad" },
{ EV(ENCL_BAD_PHY),                         EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s phy bad for slot %d" },
{ EV(ENCL_UNSTABLE),                        EL(ENCL),   EC_C,   0,    EA(PD),     "Enclosure %s is unstable" },
{ EV(ENCL_HARDWARE_ERROR),                  EL(ENCL),   EC_C,   0,    EA(PD),     "Enclosure %s hardware error" },
{ EV(ENCL_NOT_RESPONDING),                  EL(ENCL),   EC_C,   0,    EA(PD),     "Enclosure %s not responding" },
{ EV(ENCL_SAS_SATA_MIXING_DETECTED),        EL(ENCL)+EL(PD),EC_W,ECB_H,EA(PD),    "SAS/SATA mixing not supported in enclosure; %s disabled" },
{ EV(ENCL_SES_HOTPLUG_DETECTED),            EL(ENCL),   EC_W,   ECB_H,EA(PD),     "Enclosure (SES) hotplug on %s was detected, but is not supported" },
{ EV(CLUSTER_ENABLED),                      EL(CLUSTER),EC_I,   0,    EA(NONE),   "Clustering enabled" },
{ EV(CLUSTER_DISABLED),                     EL(CLUSTER),EC_I,   0,    EA(NONE),   "Clustering disabled" },
{ EV(PD_TOO_SMALL_FOR_AUTO_REBUILD),        EL(PD),     EC_I,   ECB_B,EA(PD),     "PD too small to be used for auto-rebuild on %s" },
{ EV(BBU_GOOD),                             EL(BBU),    EC_I,   ECB_H,EA(NONE),   "BBU enabled; changing WT virtual disks to WB" },
{ EV(BBU_BAD),                              EL(BBU),    EC_W,   ECB_H,EA(NONE),   "BBU disabled; changing WB virtual disks to WT, Forced WB VDs are not affected" },
{ EV(PD_BBM_LOG_80_PERCENT_FULL),           EL(PD),     EC_W,   ECB_B,EA(PD),     "Bad block table on %s is 80%% full" },
{ EV(PD_BBM_LOG_FULL),                      EL(PD),     EC_F,   0,    EA(PD_LBA), "Bad block table on %s is full; unable to log block %llx" },
{ EV(LD_CC_OWNERSHIP_LOSS_ABORT),           EL(LD),     EC_I,   0,    EA(LD),     "Consistency Check Aborted Due to Ownership Loss on %s" },
{ EV(LD_BGI_OWNERSHIP_LOSS_ABORT),          EL(LD),     EC_I,   0,    EA(LD),     "Background Initialization (BGI) Aborted Due to Ownership Loss on %s" },
{ EV(BBU_BATTERY_SOH_INVALID),              EL(BBU),    EC_C,   0,    EA(NONE),   "Battery/charger problems detected; SOH Bad" },
{ EV(CTRL_MEM_ECC_SINGLE_BIT_WARNING),      EL(CTRL),   EC_W,   ECB_H,EA(ECC),    "Single-bit ECC error: ECAR=%x, ELOG=%x, (%s); warning threshold exceeded" },
{ EV(CTRL_MEM_ECC_SINGLE_BIT_CRITICAL),     EL(CTRL),   EC_C,   0,    EA(ECC),    "Single-bit ECC error: ECAR=%x, ELOG=%x, (%s); critical threshold exceeded" },
{ EV(CTRL_MEM_ECC_SINGLE_BIT_DISABLED),     EL(CTRL),   EC_C,   0,    EA(ECC),    "Single-bit ECC error: ECAR=%x, ELOG=%x, (%s); further reporting disabled" },
{ EV(ENCL_POWER_SUPPLY_OFF),                EL(ENCL),   EC_W,   ECB_H,EA(PD_INDEX),"Enclosure %s Power supply %d switched off" },
{ EV(ENCL_POWER_SUPPLY_ON),                 EL(ENCL),   EC_I,   ECB_H,EA(PD_INDEX),"Enclosure %s Power supply %d switched on" },
{ EV(ENCL_POWER_SUPPLY_CABLE_REMOVED),      EL(ENCL),   EC_W,   ECB_H,EA(PD_INDEX),"Enclosure %s Power supply %d cable removed" },
{ EV(ENCL_POWER_SUPPLY_CABLE_INSERTED),     EL(ENCL),   EC_I,   ECB_H,EA(PD_INDEX),"Enclosure %s Power supply %d cable inserted" },
{ EV(ENCL_FAN_RETURNED_TO_NORMAL),          EL(ENCL),   EC_I,   ECB_H,EA(PD_INDEX),"Enclosure %s Fan %d returned to normal" },
{ EV(DIAG_BBU_RETENTION_TEST_STARTED_ON_PREV_BOOT),
                                            EL(CTRL),   EC_I,   0,    EA(NONE),   "BBU Retention test was initiated on previous boot" },
{ EV(DIAG_BBU_RETENTION_PASSED),            EL(CTRL),   EC_I,   0,    EA(NONE),   "BBU Retention test passed" },
{ EV(DIAG_BAT_RETENTION_TEST_FAILED),       EL(CTRL),   EC_C,   0,    EA(NONE),   "BBU Retention test failed!" },
{ EV(DIAG_NVRAM_RET_TEST_STARTED_ON_PREV_BOOT),
                                            EL(CTRL),   EC_I,   0,    EA(NONE),   "NVRAM Retention test was initiated on previous boot" },
{ EV(DIAG_NVRAM_RENTION_TEST_SUCCESS),      EL(CTRL),   EC_I,   0,    EA(NONE),   "NVRAM Retention test passed" },
{ EV(DIAG_NVRAM_RENTION_TEST_FAILED),       EL(CTRL),   EC_C,   0,    EA(NONE),   "NVRAM Retention test failed!" },
{ EV(DIAG_SELF_CHECK_TEST_PASS),            EL(CTRL),   EC_I,   0,    EA(DIAG_PASS),"%s test completed %d passes successfully" },
{ EV(DIAG_SELF_CHECK_TEST_FAIL),            EL(CTRL),   EC_C,   0,    EA(DIAG_FAIL),"%s test FAILED on %d pass. Fail data: errorOffset=%x goodData=%x badData=%x" },
{ EV(DIAG_SELF_CHECK_DONE),                 EL(CTRL),   EC_I,   0,    EA(NONE),    "Self check diagnostics completed" },
{ EV(FOREIGN_CFG_DETECTED),                 EL(CONFIG), EC_I,   ECB_B,EA(NONE),   "Foreign Configuration Detected" },
{ EV(FOREIGN_CFG_IMPORTED),                 EL(CONFIG), EC_I,   ECB_B,EA(NONE),   "Foreign Configuration Imported" },
{ EV(FOREIGN_CFG_CLEARED),                  EL(CONFIG), EC_I,   ECB_B,EA(NONE),   "Foreign Configuration Cleared" },
{ EV(NVRAM_CORRUPT),                        EL(CTRL),   EC_W,   ECB_H,EA(NONE),   "NVRAM is corrupt; reinitializing" },
{ EV(NVRAM_MISMATCH),                       EL(CTRL),   EC_W,   ECB_H,EA(NONE),   "NVRAM mismatch occurred" },
{ EV(SAS_WIDE_PORT_LINK_LOST),              EL(SAS),    EC_W,   ECB_H,EA(PORT_PHY),"SAS wide port %d lost link on PHY %d" },
{ EV(SAS_WIDE_PORT_LINK_RESTORED),          EL(SAS),    EC_I,   ECB_H,EA(PORT_PHY),"SAS wide port %d restored link on PHY %d" },
{ EV(SAS_PHY_ERROR_RATE_EXCEEDED),          EL(SAS),    EC_W,   ECB_H,EA(PORT_PHY),"SAS port %d, PHY %d has exceeded the allowed error rate" },
{ EV(SATA_BAD_BLOCK_REMAPED),               EL(PD),     EC_I,   ECB_H,EA(PD_LBA_LBA),"Bad block reassigned on %s at %llx to %llx" },
{ EV(CTRL_HOTPLUG_DETECTED),                EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller Hot Plug detected" },
{ EV(ENCL_TEMPERATURE_DIFFERENTIAL),        EL(ENCL),   EC_W,   ECB_H,EA(PD_INDEX),"Enclosure %s temperature sensor %d differential detected" },
{ EV(DIAG_DISK_TEST_CANNOT_START),          EL(CTRL),   EC_I,   0,    EA(NONE),   "Disk test cannot start. No qualifying disks found" },
{ EV(DIAG_TIME_NOT_SUFFICIENT),             EL(CTRL),   EC_I,   0,    EA(NONE),   "Time duration provided by host is not sufficient for self check" },
{ EV(PD_MARK_MISSING),                      EL(CONFIG)+EL(PD),EC_I,ECB_B,EA(PD_MISSING),"Marked Missing for %s on array %d row %d" },
{ EV(PD_REPLACE_MISSING),                   EL(CONFIG)+EL(PD),EC_I,ECB_B,EA(PD_MISSING),"Replaced Missing as %s on array %d row %d" },
{ EV(ENCL_TEMPERATURE_RETURNED_TO_NORMAL),  EL(ENCL),   EC_I,   ECB_H,EA(PD_INDEX),"Enclosure %s temperature sensor %d returned to normal" },
{ EV(ENCL_FIRMWARE_FLASH_IN_PROGRESS),      EL(ENCL),   EC_I,   ECB_I,EA(PD),     "Enclosure %s Firmware download in progress" },
{ EV(ENCL_FIRMWARE_DOWNLOAD_FAILED),        EL(ENCL),   EC_W,   ECB_I,EA(PD),     "Enclosure %s Firmware download failed" },
{ EV(PD_NOT_CERTIFIED),                     EL(PD),     EC_W,   ECB_I,EA(PD),     "%s is not a certified drive" },
{ EV(CTRL_CACHE_DISCARD_BY_USER),           EL(CTRL),   EC_I,   ECB_B,EA(NONE),   "Dirty cache data discarded by user" },
{ EV(CTRL_BOOT_MISSING_PDS),                EL(CTRL),   EC_W,   ECB_I,EA(NONE),   "PDs missing from configuration at boot" },
{ EV(CTRL_BOOT_LDS_WILL_GO_OFFLINE),        EL(CTRL),   EC_W,   ECB_B,EA(STR),    "VDs missing drives and will go offline at boot: %s" },
{ EV(CTRL_BOOT_LDS_MISSING),                EL(CTRL),   EC_W,   ECB_B,EA(STR),    "VDs missing at boot: %s" },
{ EV(CTRL_BOOT_CONFIG_MISSING),             EL(CTRL),   EC_W,   ECB_I,EA(NONE),   "Previous configuration completely missing at boot" },
{ EV(BBU_CHARGE_COMPLETE),                  EL(BBU),    EC_I,   ECB_H,EA(NONE),   "Battery charge complete" },
{ EV(ENCL_FAN_SPEED_CHANGED),               EL(ENCL),   EC_I,   ECB_N,EA(PD_INDEX),"Enclosure %s fan %d speed changed" },
{ EV(PD_SPARE_DEDICATED_IMPORTED_AS_GLOBAL),EL(PD)+EL(CONFIG),EC_I,0, EA(PD),     "Dedicated spare %s imported as global due to missing arrays" },
{ EV(PD_NO_REBUILD_SAS_SATA_MIX_NOT_ALLOWED_IN_LD), EL(PD)+EL(CONFIG),EC_I,ECB_B,EA(PD),"%s rebuild not possible as SAS/SATA is not supported in an array" },
{ EV(SEP_IS_BEING_REBOOTED),                EL(ENCL),   EC_I,   ECB_H,EA(PD),     "SEP %s has been rebooted as part of enclosure firmware download. It will be unavailable until reboot completes." },
{ EV(PD_INSERTED_EXT),                      EL(PD),     EC_I,   ECB_N,EA(PD_ADDRESS), "Inserted: %s Info: %s" },
{ EV(PD_REMOVED_EXT),                       EL(PD),     EC_I,   ECB_N,EA(PD_ADDRESS), "Removed: %s Info: %s" },
{ EV(LD_OPTIMAL),                           EL(LD),     EC_I,   0,    EA(LD),     "%s is now OPTIMAL" },
{ EV(LD_PARTIALLY_DEGRADED),                EL(LD),     EC_W,   0,    EA(LD),     "%s is now PARTIALLY DEGRADED" },
{ EV(LD_DEGRADED),                          EL(LD),     EC_C,   0,    EA(LD),     "%s is now DEGRADED" },
{ EV(LD_OFFLINE),                           EL(LD),     EC_F,   0,    EA(LD),     "%s is now OFFLINE" },
{ EV(BBU_RELEARN_REQUESTED),                EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Battery requires reconditioning; please initiate a LEARN cycle" },
{ EV(LD_DISABLED_NO_SUPPORT_FOR_RAID5),     EL(LD),     EC_W,   0,    EA(LD),     "VD %s disabled because RAID-5 is not supported by this RAID key" },
{ EV(LD_DISABLED_NO_SUPPORT_FOR_RAID6),     EL(LD),     EC_W,   0,    EA(LD),     "VD %s disabled because RAID-6 is not supported by this controller" },
{ EV(LD_DISABLED_NO_SUPPORT_FOR_SAS),       EL(LD),     EC_W,   0,    EA(LD),     "VD %s disabled because SAS drives are not supported by this RAID key" },
{ EV(CTRL_BOOT_MISSING_PDS_EXT),            EL(CTRL),   EC_W,   ECB_I,EA(STR),    "PD missing: %s" },
{ EV(CTRL_PUNCTURE_ENABLED),                EL(CTRL),   EC_W,   0,    EA(NONE),   "Puncturing of LBAs enabled" },
{ EV(CTRL_PUNCTURE_DISABLED),               EL(CTRL),   EC_W,   0,    EA(NONE),   "Puncturing of LBAs disabled" },
{ EV(ENCL_SIM_NOT_INSTALLED),               EL(ENCL),   EC_C,   0,    EA(PD_INDEX),"Enclosure %s EMM %d not installed" },
{ EV(PACKAGE_VERSION),                      EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Package version %s" },
{ EV(PD_SPARE_AFFINITY_IGNORED),            EL(PD)+EL(CONFIG),EC_W,0, EA(PD_SPARE),"Global affinity Hot Spare %s commissioned in a different enclosure" },
{ EV(FOREIGN_CFG_TABLE_OVERFLOW),           EL(CONFIG), EC_W,   0,    EA(NONE),   "Foreign configuration table overflow" },
{ EV(FOREIGN_CFG_PARTIAL_IMPORT),           EL(CONFIG), EC_W,   0,    EA(BITMAP), "Partial foreign configuration imported, PDs not imported:%s" },
{ EV(SAS_MUX_ACTIVATED_CONNECTOR),          EL(SAS),    EC_I,   ECB_H,EA(CONNECTOR), "Connector %s is active" },
{ EV(CTRL_FRU),                             EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Board Revision %s" },
{ EV(PD_COMMAND_TIMEOUT),                   EL(PD),     EC_W,   ECB_H,EA(CDB_SENSE), "Command timeout on %s, CDB:%s" },
{ EV(PD_RESET),                             EL(PD),     EC_W,   ECB_H,EA(PD_ERR), "%s reset (Type %02x)" },
{ EV(LD_BBM_LOG_80_PERCENT_FULL),           EL(LD),     EC_W,   ECB_B,EA(LD),     "Bad block table on %s is 80%% full" },
{ EV(LD_BBM_LOG_FULL),                      EL(LD),     EC_F,   0,    EA(LD_LBA_PD_LBA),
                                                                            "Bad block table on %s is full; unable to log block %llx (on %s at %llx)" },
{ EV(LD_LOG_MEDIUM_ERROR),                  EL(LD),     EC_F,   0,    EA(LD_LBA_PD_LBA), "Uncorrectable medium error logged for %s at %llx (on %s at %llx)" },
{ EV(LD_CORRECTED_MEDIUM_ERROR),            EL(LD),     EC_I,   0,    EA(LD_LBA), "Medium error corrected on %s at %llx" },
{ EV(PD_BBM_LOG_100_PERCENT_FULL),          EL(PD),     EC_W,   ECB_B,EA(PD),     "Bad block table on %s is 100%% full" },
{ EV(LD_BBM_LOG_100_PERCENT_FULL),          EL(LD),     EC_W,   ECB_B,EA(LD),     "Bad block table on %s is 100%% full" },
{ EV(DIAG_FAULTY_IOP_DETECTED),             EL(CTRL),   EC_F,   0,    EA(NONE),   "Controller needs replacement, IOP is faulty" },
{ EV(PD_COPYBACK_START),                    EL(PD),     EC_I,   ECB_B,EA(PD_PD),  "CopyBack started on %s from %s" },
{ EV(PD_COPYBACK_ABORT),                    EL(PD),     EC_I,   ECB_B,EA(PD_PD),  "CopyBack aborted on %s and src is %s" },
{ EV(PD_COPYBACK_DONE),                     EL(PD),     EC_I,   ECB_B,EA(PD_PD),  "CopyBack complete on %s from %s" },
{ EV(PD_COPYBACK_PROGRESS),                 EL(PD),     EC_P,   0,    EA(PD_PROG),"CopyBack progress on %s is %s" },
{ EV(PD_COPYBACK_RESUME),                   EL(PD),     EC_I,   0,    EA(PD_PD),  "CopyBack resumed on %s from %s" },
{ EV(PD_COPYBACK_AUTO),                     EL(PD),     EC_I,   ECB_B,EA(PD_PD),  "CopyBack automatically started on %s from %s" },
{ EV(PD_COPYBACK_FAILED),                   EL(PD),     EC_C,   0,    EA(PD_PD),  "CopyBack failed on %s due to source %s error" },
{ EV(CTRL_EPOW_UNSUCCESSFUL),               EL(CTRL),   EC_W,   ECB_H,EA(NONE),   "Early Power off warning was unsuccessful" },
{ EV(BBU_FRU),                              EL(CTRL),   EC_I,   ECB_I,EA(STR),    "BBU FRU is %s" },
{ EV(PD_FRU),                               EL(PD),     EC_I,   ECB_I,EA(PD_FRU), "%s FRU is %s" },
{ EV(CTRL_HW_REVISION),                     EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Controller hardware revision ID %s" },
{ EV(FOREIGN_CFG_UPGRADE_REQUIRED),         EL(CONFIG), EC_W,   0,    EA(NONE),   "Foreign import shall result in a backward incompatible upgrade of configuration metadata" },
{ EV(PD_SAS_REDUNDANT_PATH_RESTORED),       EL(PD)+EL(SAS),EC_I,ECB_H,EA(PD_PATHINFO), "Redundant path restored for %s" },
{ EV(PD_SAS_REDUNDANT_PATH_BROKEN),         EL(PD)+EL(SAS),EC_W,ECB_H,EA(PD_PATHINFO), "Redundant path broken for %s" },
{ EV(ENCL_REDUNDANT_ENCL_MODULE_INSERTED),  EL(ENCL),   EC_I,   ECB_H,EA(PD_PD),  "Redundant enclosure EMM %s inserted for EMM %s" },
{ EV(ENCL_REDUNDANT_ENCL_MODULE_REMOVED),   EL(ENCL),   EC_W,   ECB_H,EA(PD_PD),  "Redundant enclosure EMM %s removed for EMM %s" },
{ EV(CTRL_PR_CANT_START),                   EL(CTRL),   EC_I,   ECB_B,EA(NONE),   "Patrol Read can't be started, as PDs are either not ONLINE, or are in a VD with an active process, or are in an excluded VD" },
{ EV(PD_COPYBACK_ABORT_BY_USER),            EL(PD),     EC_I,   ECB_B,EA(PD_PD),  "Copyback aborted by user on %s and src is %s" },
{ EV(PD_COPYBACK_ABORT_FOR_SPARE),          EL(PD),     EC_C,   0,    EA(PD_PD),  "Copyback aborted on hot spare %s from %s, as hot spare needed for rebuild" },
{ EV(PD_COPYBACK_ABORT_FOR_REBUILD),        EL(PD),     EC_W,   ECB_B,EA(PD_PD),  "Copyback aborted on %s from %s, as rebuild required in the array" },
{ EV(LD_CACHE_DISCARDED),                   EL(LD),     EC_F,   0,    EA(LD),     "Controller cache discarded for deleted, missing or offline %s" },
{ EV(PD_TOO_SMALL_FOR_COPYBACK),            EL(PD),     EC_I,   ECB_B,EA(PD_PD),  "Copyback cannot be started as %s is too small for src %s" },
{ EV(PD_NO_COPYBACK_SAS_SATA_MIX_NOT_ALLOWED_IN_LD), EL(PD)+EL(CONFIG),EC_I,ECB_B,EA(PD_PD),
                                                                            "Copyback cannot be started on %s from %s, as SAS/SATA is not supported in an array" },
{ EV(PD_FW_DOWNLOAD_START),                 EL(PD),     EC_I,   ECB_I,EA(PD),     "Microcode update started on %s" },
{ EV(PD_FW_DOWNLOAD_COMPLETE),              EL(PD),     EC_I,   ECB_I,EA(PD),     "Microcode update completed on %s" },
{ EV(PD_FW_DOWNLOAD_TIMEOUT),               EL(PD),     EC_W,   0,    EA(PD),     "Microcode update timeout on %s" },
{ EV(PD_FW_DOWNLOAD_FAILED),                EL(PD),     EC_W,   ECB_I,EA(PD),     "Microcode update failed on %s" },
{ EV(CTRL_PROP_CHANGED),                    EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller properties changed" },
{ EV(CTRL_PR_PROP_CHANGED),                 EL(CTRL),   EC_I,   0,    EA(NONE),   "Patrol Read properties changed" },
{ EV(CTRL_CC_SCHEDULE_PROP_CHANGED),        EL(CTRL),   EC_I,   0,    EA(NONE),   "CC Schedule properties changed" },
{ EV(BBU_PROP_CHANGED),                     EL(BBU),    EC_I,   0,    EA(NONE),   "Battery properties changed" },
{ EV(BBU_PERIODIC_RELEARN_PENDING),         EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Periodic Battery Relearn is pending. Please initiate manual learn cycle as Automatic learn is not enabled" },
{ EV(CTRL_LOCK_KEY_CREATED),                EL(CTRL),   EC_I,   0,    EA(NONE),   "Drive security key created" },
{ EV(CTRL_LOCK_KEY_BACKEDUP),               EL(CTRL),   EC_I,   0,    EA(NONE),   "Drive security key backed up" },
{ EV(CTRL_LOCK_KEY_VERIFIED_ESCROW),        EL(CTRL),   EC_I,   0,    EA(NONE),   "Drive security key from escrow, verified" },
{ EV(CTRL_LOCK_KEY_REKEYED),                EL(CTRL),   EC_I,   0,    EA(NONE),   "Drive security key changed" },
{ EV(CTRL_LOCK_KEY_REKEY_FAILED),           EL(CTRL),   EC_W,   0,    EA(NONE),   "Drive security key, re-key operation failed" },
{ EV(CTRL_LOCK_KEY_INVALID),                EL(CTRL),   EC_W,   0,    EA(NONE),   "Drive security key is invalid" },
{ EV(CTRL_LOCK_KEY_DESTROYED),              EL(CTRL),   EC_I,   0,    EA(NONE),   "Drive security key destroyed" },
{ EV(CTRL_ESCROW_KEY_INVALID),              EL(CTRL),   EC_W,   0,    EA(NONE),   "Drive security key from escrow is invalid" },
{ EV(LD_SECURED),                           EL(LD),     EC_I,   ECB_B,EA(LD),     "%s is now secured" },
{ EV(LD_PARTIALLY_SECURED),                 EL(LD),     EC_W,   0,    EA(LD),     "%s is partially secured" },
{ EV(PD_SECURED),                           EL(PD),     EC_I,   ECB_H,EA(PD),     "%s security activated" },
{ EV(PD_UNSECURED),                         EL(PD),     EC_I,   ECB_H,EA(PD),     "%s security disabled" },
{ EV(PD_REPROVISIONED),                     EL(PD),     EC_I,   ECB_H,EA(PD),     "%s is reprovisioned" },
{ EV(PD_LOCK_KEY_REKEYED),                  EL(PD),     EC_I,   ECB_H,EA(PD),     "%s security key changed" },
{ EV(PD_SECURITY_FAILURE),                  EL(PD),     EC_F,   0,    EA(PD),     "Security subsystem problems detected for %s" },
{ EV(LD_CACHE_PINNED),                      EL(CTRL)+EL(LD), EC_F, 0, EA(LD),     "Controller cache pinned for missing or offline %s" },
{ EV(CTRL_BOOT_LDS_CACHE_PINNED),           EL(CTRL)+EL(LD), EC_F, 0, EA(BITMAP), "Controller cache pinned for missing or offline VDs: %s" },
{ EV(CTRL_LDS_CACHE_DISCARDED_BY_USER),     EL(CTRL)+EL(LD), EC_I, 0, EA(BITMAP), "Controller cache discarded by user for VDs: %s" },
{ EV(LD_CACHE_DESTAGED),                    EL(CTRL)+EL(LD), EC_I, ECB_B,EA(LD),     "Controller cache destaged for %s" },
{ EV(LD_CC_STARTED_ON_INCONSISTENT_LD),     EL(LD),     EC_W,   0,    EA(LD),     "Consistency Check started on an inconsistent %s" },
{ EV(CTRL_LOCK_KEY_FAILED),                 EL(CTRL),   EC_W,   ECB_B,EA(NONE),   "Drive security key failure, cannot access secured configuration" },
{ EV(CTRL_SECRET_KEY_INVALID),              EL(CTRL),   EC_W,   0,    EA(NONE),   "Drive security pass phrase from user is invalid" },
{ EV(BBU_REMOTE_CONNECTOR_ERROR),           EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Detected error with the remote battery connector cable" },
{ EV(PD_POWER_STATE_CHANGE),                EL(PD),     EC_I,   ECB_N,EA(PD_POWER_STATE),"Power state change on %s from %s to %s" },
{ EV(ENCL_ELEMENT_STATUS_CHANGED),          EL(ENCL),   EC_I,   ECB_H,EA(PD_INDEX),"Enclosure %s element (SES code 0x%x) status changed" },
{ EV(PD_NO_REBUILD_HDD_SSD_MIX_NOT_ALLOWED_IN_LD), EL(PD)+EL(CONFIG),EC_I,ECB_H,EA(PD),  "%s rebuild not possible as HDD/SSD mix is not supported in an array" },
{ EV(PD_NO_COPYBACK_HDD_SSD_MIX_NOT_ALLOWED_IN_LD), EL(PD)+EL(CONFIG),EC_I,ECB_H,EA(PD_PD),
                                                                            "Copyback cannot be started on %s from %s, as HDD/SSD mix is not supported in an array" },
{ EV(LD_BBM_LOG_CLEARED),                   EL(LD),     EC_I,   ECB_B,EA(LD),     "Bad block table on %s is cleared" },
{ EV(SAS_TOPOLOGY_ERROR),                   EL(SAS),    EC_C,   0,    EA(GENERIC),"SAS topology error: 0x%llx" },
{ EV(LD_CORRECTED_CLUSTER_OF_MEDIUM_ERRORS),EL(LD),     EC_I,   0,    EA(LD_LBA_PD_LBA), "Cluster of medium errors corrected for %s at %llx (on %s at %llx)" },
{ EV(CTRL_HOST_BUS_SCAN_REQUESTED),         EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller requests a host bus rescan" },
{ EV(CTRL_FACTORY_REPURPOSED),              EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller repurposed and factory defaults restored" },
{ EV(CTRL_LOCK_KEY_BINDING_UPDATED),        EL(CTRL),   EC_I,   0,    EA(NONE),   "Drive security key binding updated" },
{ EV(CTRL_LOCK_KEY_EKM_MODE),               EL(CTRL),   EC_I,   0,    EA(NONE),   "Drive security is in external key management mode" },
{ EV(CTRL_LOCK_KEY_EKM_FAILURE),            EL(CTRL),   EC_W,   ECB_B,EA(NONE),   "Drive security failed to communicate with external key manager" },
{ EV(PD_LOCK_KEY_REQUIRED),                 EL(PD),     EC_I,   0,    EA(KEYINFO),"%s needs key to be %s %s" },
{ EV(LD_SECURE_FAILED),                     EL(LD),     EC_W,   0,    EA(LD),     "%s secure failed" },
{ EV(CTRL_ONLINE_RESET),                    EL(CTRL),   EC_C,   0,    EA(NONE),   "Controller encountered a fatal error and was reset" },
{ EV(LD_SNAPSHOT_ENABLED),                  EL(LD),     EC_I,   0,    EA(LD_LD),  "Snapshots enabled on %s (Repository %s)" },
{ EV(LD_SNAPSHOT_DISABLED_BY_USER),         EL(LD),     EC_I,   0,    EA(LD_LD),  "Snapshots disabled on %s (Repository %s) by the user" },
{ EV(LD_SNAPSHOT_DISABLED_INTERNALLY),      EL(LD),     EC_C,   0,    EA(LD_LD),  "Snapshots disabled on %s (Repository %s), due to a fatal error" },
{ EV(LD_SNAPSHOT_PIT_CREATED),              EL(LD),     EC_I,   0,    EA(LD_PIT), "Snapshot created on %s at %s" },
{ EV(LD_SNAPSHOT_PIT_DELETED),              EL(LD),     EC_I,   0,    EA(LD_PIT), "Snapshot deleted on %s at %s" },
{ EV(LD_SNAPSHOT_VIEW_CREATED),             EL(LD),     EC_I,   0,    EA(LD_VIEW),"View created at %s to a snapshot at %s for %s" },
{ EV(LD_SNAPSHOT_VIEW_DELETED),             EL(LD),     EC_I,   0,    EA(LD_VIEW),"View at %s is deleted, to snapshot at %s for %s" },
{ EV(LD_SNAPSHOT_ROLLBACK_STARTED),         EL(LD),     EC_I,   0,    EA(LD_PIT), "Snapshot rollback started on %s from snapshot at %s" },
{ EV(LD_SNAPSHOT_ROLLBACK_ABORTED),         EL(LD),     EC_F,   0,    EA(LD_PIT), "Snapshot rollback on %s internally aborted for snapshot at %s" },
{ EV(LD_SNAPSHOT_ROLLBACK_COMPLETED),       EL(LD),     EC_I,   0,    EA(LD_PIT), "Snapshot rollback on %s completed for snapshot at %s" },
{ EV(LD_SNAPSHOT_ROLLBACK_PROGRESS),        EL(LD),     EC_P,   0,    EA(LD_SNAP_PROG),  "Snapshot rollback progress for snapshot at %s, on %s is %s" },
{ EV(LD_SNAPSHOT_REPOSITORY_80_PERCENT_FULL), EL(LD),   EC_W,   0,    EA(LD_LD),  "Snapshot space for %s in snapshot repository %s, is 80%% full" },
{ EV(LD_SNAPSHOT_REPOSITORY_FULL),          EL(LD),     EC_C,   0,    EA(LD_LD),  "Snapshot space for %s in snapshot repository %s, is full" },
{ EV(LD_SNAPSHOT_VIEW_80_PERCENT_FULL),     EL(LD),     EC_W,   0,    EA(LD_VIEW),"View at %s to snapshot at %s, is 80%% full on snapshot repository %s" },
{ EV(LD_SNAPSHOT_VIEW_FULL),                EL(LD),     EC_C,   0,    EA(LD_VIEW),"View at %s to snapshot at %s, is full on snapshot repository %s" },
{ EV(LD_SNAPSHOT_REPOSITORY_LOST),          EL(LD),     EC_C,   0,    EA(LD),     "Snapshot repository lost for %s" },
{ EV(LD_SNAPSHOT_REPOSITORY_RESTORED),      EL(LD),     EC_W,   0,    EA(LD),     "Snaphot repository restored for %s" },
{ EV(LD_SNAPSHOT_INTERNAL_ERROR),           EL(LD),     EC_C,   0,    EA(GENERIC),"Snapshot encountered an unexpected internal error: 0x%llx"},
{ EV(LD_SNAPSHOT_AUTO_ENABLED),             EL(LD),     EC_I,   0,    EA(LD_LD),  "Auto Snapshot enabled on %s (snapshot repository %s)" },
{ EV(LD_SNAPSHOT_AUTO_DISABLED),            EL(LD),     EC_I,   0,    EA(LD_LD),  "Auto Snapshot disabled on %s (snapshot repository %s)" },
{ EV(CFG_CMD_LOST),                         EL(CONFIG), EC_C,   0,    EA(NONE),   "Configuration command could not be committed to disk, please retry" },
{ EV(PD_COD_STALE),                         EL(PD),     EC_I,   0,    EA(PD),     "COD on %s updated as it was stale" },
{ EV(PD_POWER_STATE_CHANGE_FAILED),         EL(PD),     EC_W,   0,    EA(PD_POWER_STATE), "Power state change failed on %s (from %s to %s)" },
{ EV(LD_NOT_READY),                         EL(LD),     EC_W,   0,    EA(LD),     "%s is not available" },
{ EV(LD_IS_READY),                          EL(LD),     EC_I,   0,    EA(LD),     "%s is available" },
{ EV(LD_IS_SSC),                            EL(LD),     EC_I,   0,    EA(LD_LBA), "%s is used for CacheCade(TM) with capacity 0x%llx logical blocks" },
{ EV(LD_IS_USING_SSC),                      EL(LD),     EC_I,   0,    EA(LD_LD),  "%s is using CacheCade(TM) %s" },
{ EV(LD_IS_NOT_USING_SSC),                  EL(LD),     EC_I,   0,    EA(LD_LD),  "%s is no longer using CacheCade(TM) %s" },
{ EV(LD_SNAPSHOT_FREED_RESOURCE),           EL(LD),     EC_C,   0,    EA(LD_LD),  "Snapshot deleted due to resource constraints for %s in snapshot repository %s" },
{ EV(LD_SNAPSHOT_AUTO_FAILED),              EL(LD),     EC_W,   0,    EA(LD_LD),  "Auto Snapshot failed for %s in snapshot repository %s" },
{ EV(CTRL_RESET_EXPANDER),                  EL(CTRL),   EC_W,   ECB_H,EA(NONE),   "Controller reset on-board expander" },
{ EV(LD_SSC_SIZE_CHANGED),                  EL(LD),     EC_W,   0,    EA(LD_LBA), "CacheCade(TM) (%s) capacity changed and is now 0x%llx logical blocks" },
{ EV(BBU_CANNOT_DO_TRANSPARENT_LEARN),      EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Battery life has degraded and cannot initiate transparent learn cycles" },
{ EV(CTRL_PFK_APPLIED),                     EL(CTRL),   EC_I,   0,    EA(PFINFO), "Advanced Software Options %s key was applied for - %s" },
{ EV(LD_SNAPSHOT_SCHEDULE_PROP_CHANGE),     EL(LD),     EC_I,   0,    EA(BITMAP), "Snapshot schedule properties changed on %s" },
{ EV(LD_SNAPSHOT_SCHEDULED_ACTION_DUE),     EL(LD),     EC_I,   0,    EA(BITMAP), "Snapshot scheduled action is due on %s" },
{ EV(CTRL_PERF_COLLECTION),                 EL(CTRL),   EC_DBG, 0,    EA(GENERIC),"Performance Metrics: collection command 0x%llx" },
{ EV(CTRL_PFK_TRANSFERRED),                 EL(CTRL),   EC_I,   0,    EA(PFINFO), "Advanced Software Options %s key was transferred - %s" },
{ EV(CTRL_PFK_SERIALNUM),                   EL(CTRL),   EC_I,   0,    EA(STR),    "Advanced Software Options Serial number %s" },
{ EV(CTRL_PFK_SERIALNUM_MISMATCH),          EL(CTRL),   EC_W,   0,    EA(STR),    "Advanced Software Options Serial number mismatched. Key Vault Serial number - %s" },
{ EV(BBU_REPLACEMENT_NEEDED_SOH_NOT_OPTIMAL), EL(BBU),  EC_W,   ECB_H,EA(GENERIC),"Battery cannot support data retention for more than %d hours. Please replace the battery" },
{ EV(LD_POWER_STATE_CHANGE),                EL(LD),     EC_I,   ECB_N,EA(LD_PROP_PS),"%s power policy changed to %s (from %s)" },
{ EV(LD_POWER_STATE_MAX_UNAVAILABLE),       EL(LD),     EC_W,   0,    EA(LD),     "%s cannot transition to max power savings" },
{ EV(CTRL_HOST_DRIVER_LOADED),              EL(CTRL),   EC_I,   ECB_I,EA(NONE),   "Host driver is loaded and operational" },
{ EV(LD_MIRROR_BROKEN),                     EL(LD),     EC_I,   0,    EA(LD),     "%s mirror broken" },
{ EV(LD_MIRROR_JOINED),                     EL(LD),     EC_I,   0,    EA(LD),     "%s mirror joined" },
{ EV(PD_SAS_WIDE_PORT_LINK_FAILURE),        EL(PD)+EL(SAS),EC_W,ECB_H,EA(PD_INDEX),"%s link %d failure in wide port" },
{ EV(PD_SAS_WIDE_PORT_LINK_RESTORED),       EL(PD)+EL(SAS),EC_I,ECB_H,EA(PD_INDEX),"%s link %d restored in wide port" },
{ EV(TMM_FRU),                              EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Memory module FRU is %s" },
{ EV(BBU_REPLACEMENT_NEEDED),               EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Cache-vault power pack is sub-optimal. Please replace the pack." },
{ EV(FOREIGN_CFG_AUTO_IMPORT_NONE),         EL(CONFIG), EC_W,   0,    EA(NONE),   "Foreign configuration auto-import did not import any drives" },
{ EV(BBU_MICROCODE_UPDATE_REQUIRED),        EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Cache-vault microcode update required." },
{ EV(LD_SSC_SIZE_EXCEEDED),                 EL(LD),     EC_W,   0,    EA(LD),     "CacheCade(TM) (%s) capacity exceeds maximum allowed size, extra capacity is not used" },
{ EV(LD_PI_LOST),                           EL(LD),     EC_W,   0,    EA(LD),     "%s protection information lost" },

{ EV(PD_SHIELD_DIAG_PASS),                  EL(PD),     EC_I,   0,    EA(PD),     "Diagnostics passed for %s" },
{ EV(PD_SHIELD_DIAG_FAIL),                  EL(PD),     EC_C,   0,    EA(PD),     "Diagnostics failed for %s" },
{ EV(CTRL_SERVER_POWER_DIAG_STARTED),       EL(CTRL),   EC_I,   0,    EA(NONE),   "Server Power capability Diagnostic Test Started" },
{ EV(PD_RBLD_DRIVE_CACHE_ENABLED),          EL(PD),     EC_I,   0,    EA(PD),     "Drive Cache settings enabled during rebuild for %s" },
{ EV(PD_RBLD_DRIVE_CACHE_RESTORED),         EL(PD),     EC_I,   0,    EA(PD),     "Drive Cache settings restored after rebuild for %s" },
{ EV(PD_EMERGENCY_SPARE_COMMISSIONED),      EL(PD),     EC_I,   0,    EA(PD),     "Drive %s commissioned as Emergency spare" },
{ EV(PD_EMERGENCY_SPARE_COMMISSIONED_REMINDER),EL(PD),  EC_W,   0,    EA(PD),     "Reminder: Potential non-optimal configuration due to drive %s commissioned as emergency spare" },
{ EV(LD_CC_SUSPENDED),                      EL(LD),     EC_I,   ECB_B,EA(LD),     "Consistency Check suspended on %s" },
{ EV(LD_CC_RESUMED),                        EL(LD),     EC_I,   ECB_B,EA(LD),     "Consistency Check resumed on %s" },
{ EV(LD_BGI_SUSPENDED),                     EL(LD),     EC_I,   ECB_B,EA(LD),     "Background Initialization suspended on %s" },
{ EV(LD_BGI_RESUMED),                       EL(LD),     EC_I,   ECB_B,EA(LD),     "Background Initialization resumed on %s" },
{ EV(LD_RECON_SUSPENDED),                   EL(LD),     EC_I,   ECB_B,EA(LD),     "Reconstruction suspended on %s" },
{ EV(PD_RBLD_SUSPENDED),                    EL(PD),     EC_I,   0,    EA(PD),     "Rebuild suspended on %s" },
{ EV(PD_COPYBACK_SUSPENDED),                EL(PD),     EC_I,   0,    EA(PD),     "Copyback suspended on %s" },
{ EV(LD_CC_SUSPENDED_REMINDER),             EL(LD),     EC_I,   ECB_B,EA(LD),     "Reminder: Consistency Check suspended on %s" },
{ EV(LD_BGI_SUSPENDED_REMINDER),            EL(LD),     EC_I,   ECB_B,EA(LD),     "Reminder: Background Initialization suspended on %s" },
{ EV(LD_RECON_SUSPENDED_REMINDER),          EL(LD),     EC_I,   ECB_B,EA(LD),     "Reminder: Reconstruction suspended on %s" },
{ EV(PD_RBLD_SUSPENDED_REMINDER),           EL(PD),     EC_I,   0,    EA(PD),     "Reminder: Rebuild suspended on %s" },
{ EV(PD_COPYBACK_SUSPENDED_REMINDER),       EL(PD),     EC_I,   0,    EA(PD),     "Reminder: Copyback suspended on %s" },
{ EV(CTRL_PR_SUSPENDED_REMINDER),           EL(CTRL),   EC_I,   0,    EA(NONE),   "Reminder: Patrol Read suspended" },
{ EV(PD_ERASE_ABORTED),                     EL(PD),     EC_I,   ECB_B,EA(PD),     "Erase aborted on %s" },
{ EV(PD_ERASE_FAILED),                      EL(PD),     EC_C,   0,    EA(PD_ERR), "Erase failed on %s (Error %02x)" },
{ EV(PD_ERASE_PROGRESS),                    EL(PD),     EC_P,   0,    EA(PD_PROG),"Erase progress on %s is %s" },
{ EV(PD_ERASE_STARTED),                     EL(PD),     EC_I,   ECB_B,EA(PD),     "Erase started on %s" },
{ EV(PD_ERASE_SUCCESSFUL),                  EL(PD),     EC_I,   ECB_B,EA(PD),     "Erase completed on %s" },
{ EV(LD_ERASE_ABORTED),                     EL(LD),     EC_I,   ECB_B,EA(LD),     "Erase aborted on %s" },
{ EV(LD_ERASE_FAILED),                      EL(LD),     EC_C,   0,    EA(LD),     "Erase failed on %s" },
{ EV(LD_ERASE_PROGRESS),                    EL(LD),     EC_P,   0,    EA(LD_PROG),"Erase progress on %s is %s" },
{ EV(LD_ERASE_START),                       EL(LD),     EC_I,   ECB_B,EA(LD),     "Erase started on %s" },
{ EV(LD_ERASE_SUCCESSFUL),                  EL(LD),     EC_I,   ECB_B,EA(LD),     "Erase complete on %s" },
{ EV(LD_ERASE_POTENTIAL_LEAKAGE),           EL(LD),     EC_W,   0,    EA(LD),     "Potential leakage during erase on %s" },
{ EV(BBU_CHARGE_DISABLED_OTC),              EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Battery charging was suspended due to high battery temperature" },
{ EV(BBU_MICROCODE_UPDATED),                EL(BBU),    EC_I,   ECB_I,EA(NONE),   "NVCache firmware update was successful" },
{ EV(BBU_MICROCODE_UPDATE_FAILED),          EL(BBU),    EC_W,   ECB_I,EA(NONE),   "NVCache firmware update failed" },
{ EV(LD_ACCESS_BLOCKED_SSC_OFFLINE),        EL(LD),     EC_F,   0,    EA(LD),     "%s access blocked as cached data in CacheCade(TM) is unavailable" },

{ EV(LD_SSC_DISASSOCIATE_START),            EL(LD),     EC_I,   0,    EA(LD),     "CacheCade(TM) disassociate started on %s" },
{ EV(LD_SSC_DISASSOCIATE_DONE),             EL(LD),     EC_I,   0,    EA(LD),     "CacheCade(TM) disassociate completed on %s" },
{ EV(LD_SSC_DISASSOCIATE_FAILED),           EL(LD),     EC_C,   0,    EA(LD),     "CacheCade(TM) disassociate failed on %s" },
{ EV(LD_SSC_DISASSOCIATE_PROGRESS),         EL(LD),     EC_P,   0,    EA(LD_PROG),"CacheCade(TM) disassociate progress on %s is %s" },
{ EV(LD_SSC_DISASSOCIATE_ABORT_BY_USER),    EL(LD),     EC_I,   0,    EA(LD),     "CacheCade(TM) disassociate aborted by user on %s" },

{ EV(SAS_PHY_LINK_SPEED_UPDATED),           EL(SAS),    EC_I,   ECB_H,EA(PORT_PHY),"Link speed changed on SAS port %d and PHY %d" },
{ EV(CTRL_PFK_DEACTIVATED),                 EL(CTRL),   EC_W,   0,    EA(PFINFO), "Advanced Software Options was deactivated for - %s" },
{ EV(LD_ACCESS_UNBLOCKED),                  EL(LD),     EC_I,   ECB_B,EA(LD),     "%s is now accessible" },

{ EV(LD_IS_USING_SSC_2),                    EL(LD),     EC_I,   0,    EA(LD),     "%s is using CacheCade(TM)" },
{ EV(LD_IS_NOT_USING_SSC_2),                EL(LD),     EC_I,   0,    EA(LD),     "%s is no longer using CacheCade(TM)" },

{ EV(PD_PR_ABORTED),                        EL(PD),     EC_W,   0,    EA(PD),     "Patrol Read aborted on %s" },
{ EV(PD_TRANSIENT_ERROR_DETECTED),          EL(PD),     EC_W,   ECB_N,EA(PD),     "Transient error detected while communicating with %s" },
{ EV(LD_PI_ERR_IN_CACHE),                   EL(LD),     EC_W,   0,    EA(LD_LBA), "PI error in cache for %s at LBA %llx" },
{ EV(CTRL_FLASH_IMAGE_UNSUPPORTED),         EL(CTRL),   EC_W,   0,    EA(NONE),   "Flash downloaded image is not supported" },
{ EV(BBU_MODE_SET),                         EL(CTRL),   EC_I,   ECB_H,EA(STR),    "BBU mode selected - %s" },
{ EV(BBU_PERIODIC_RELEARN_RESCHEDULED),     EL(BBU),    EC_I,   ECB_B,EA(TIME),   "Periodic Battery Relearn was missed, and rescheduled to %s." },
{ EV(CTRL_RESETNOW_START),                  EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller reset requested by host" },
{ EV(CTRL_RESETNOW_DONE),                   EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller reset requested by host, completed" },
{ EV(L3_CACHE_ERROR),                       EL(CTRL),   EC_C,   0,    EA(NONE),   "L3 cache error has been detected"},
{ EV(L2_CACHE_ERROR),                       EL(CTRL),   EC_C,   0,    EA(NONE),   "L2 cache error has been detected"},

{ EV(CTRL_BOOT_HEADLESS_MODE_HAD_ERRORS),   EL(CTRL),   EC_W,   0,    EA(NONE),   "Controller booted in headless mode with errors" },
{ EV(CTRL_BOOT_SAFE_MODE_FOR_ERRORS),       EL(CTRL),   EC_C,   0,    EA(NONE),   "Controller booted to safe mode due to critical errors" },
{ EV(CTRL_BOOT_ERROR_WARNING),              EL(CTRL),   EC_W,   0,    EA(STR),    "Warning Error during boot - %s" },
{ EV(CTRL_BOOT_ERROR_CRITICAL),             EL(CTRL),   EC_C,   0,    EA(STR),    "Critical Error during boot - %s" },
{ EV(CTRL_BOOT_ERROR_FATAL),                EL(CTRL),   EC_F,   0,    EA(STR),    "Fatal Error during boot - %s" },

{ EV(HA_NODE_JOIN),                         EL(CLUSTER),EC_I,   0,    EA(STR),    "Peer controller has joined HA domain (ID: %s)" },
{ EV(HA_NODE_BREAK),                        EL(CLUSTER),EC_C,   0,    EA(STR),    "Peer controller has left HA domain (ID: %s)" },
{ EV(HA_PD_IS_REMOTE),                      EL(CLUSTER)+EL(PD),EC_I,0,EA(PD),     "%s is managed by peer controller" },
{ EV(HA_PD_IS_LOCAL),                       EL(CLUSTER)+EL(PD),EC_I,0,EA(PD),     "%s is managed by local controller" },
{ EV(HA_LD_IS_REMOTE),                      EL(CLUSTER)+EL(LD),EC_I,0,EA(LD),     "%s is managed by peer controller" },
{ EV(HA_LD_IS_LOCAL),                       EL(CLUSTER)+EL(LD),EC_I,0,EA(LD),     "%s is managed by local controller" },
{ EV(HA_LD_TARGET_ID_CONFLICT),             EL(CLUSTER)+EL(LD),EC_W,0,EA(LD),     "%s has a conflict in HA domain" },
{ EV(HA_LD_ACCESS_IS_SHARED),               EL(CLUSTER)+EL(LD),EC_I,0,EA(LD),     "%s access is shared" },
{ EV(HA_LD_ACCESS_IS_EXCLUSIVE),            EL(CLUSTER)+EL(LD),EC_I,0,EA(LD),     "%s access is exclusive" },
{ EV(HA_LD_INCOMPATIBLE),                   EL(CLUSTER)+EL(LD),EC_W,0,EA(LD),     "%s is incompatible in the HA domain" },
{ EV(HA_PEER_INCOMPATIBLE),                 EL(CLUSTER),EC_C,   0,    EA(NONE),   "Peer controller is incompatible" },
{ EV(HA_HW_INCOMPATIBLE),                   EL(CLUSTER),EC_C,   0,    EA(PCI),    "Controllers in the HA domain are incompatible" },
{ EV(HA_CTRLPROP_INCOMPATIBLE),             EL(CLUSTER),EC_C,   0,    EA(NONE),   "Controller properties are incompatible between local and peer controllers" },
{ EV(HA_FW_VERSION_MISMATCH),               EL(CLUSTER),EC_W,   0,    EA(NONE),   "FW versions do not match in the HA domain" },
{ EV(HA_FEATURES_MISMATCH),                 EL(CLUSTER),EC_W,   0,    EA(PFINFO), "Advanced Software Options %s do not match in the HA domain" },
{ EV(HA_CACHE_MIRROR_ONLINE),               EL(CLUSTER),EC_I,   0,    EA(NONE),   "HA cache mirror is online"},
{ EV(HA_CACHE_MIRROR_OFFLINE),              EL(CLUSTER),EC_C,   0,    EA(NONE),   "HA cache mirror is offline"},
{ EV(LD_ACCESS_BLOCKED_PEER_UNAVAILABLE),   EL(CLUSTER)+EL(LD),EC_F,0,EA(LD),     "%s access blocked as cached data from peer controller is unavailable" },
{ EV(BBU_UNSUPPORTED),                      EL(BBU),    EC_W,   ECB_H,EA(NONE),   "Cache-vault power pack is not supported. Please replace the pack" },

{ EV(PD_TEMP_HIGH),                         EL(PD),     EC_W,   ECB_H,EA(PD_TEMP),"%s temperature (%d C) is above warning threshold" },
{ EV(PD_TEMP_CRITICAL),                     EL(PD),     EC_C,   0,    EA(PD_TEMP),"%s temperature (%d C) is above critical threshold" },
{ EV(PD_TEMP_NORMAL),                       EL(PD),     EC_I,   ECB_H,EA(PD_TEMP),"%s temperature (%d C) is normal" },
{ EV(PD_IO_THROTTLED),                      EL(PD),     EC_W,   0,    EA(PD),     "%s IOs are being throttled" },
{ EV(PD_IO_NOT_THROTTLED),                  EL(PD),     EC_I,   0,    EA(PD),     "%s IOs are normal. (No throttling)" },
{ EV(PD_LIFE),                              EL(PD),     EC_I,   ECB_H,EA(PD_LIFE),"%s has %d%% life left. Life left thresholds - warning:%d%%, critical:%d%%"},
{ EV(PD_LIFE_NOT_OPTIMAL),                  EL(PD),     EC_W,   ECB_H,EA(PD_LIFE),"%s life left (%d%%) is below optimal. Life left thresholds - warning:%d%%, critical:%d%%"},
{ EV(PD_LIFE_CRITICAL),                     EL(PD),     EC_C,   0,    EA(PD_LIFE),"%s life left (%d%%) is critical. Life left thresholds - warning:%d%%, critical:%d%%"},
{ EV(PD_FAILURE_LOCKEDUP),                  EL(PD),     EC_C,   0,    EA(PD),     "%s failure, device locked-up" },
{ EV(CTRL_HOST_DRIVER_UPDATE_NEEDED),       EL(CTRL),   EC_W,   0,    EA(STR),    "Host driver needs to be upgraded %s" },
{ EV(HA_POSSIBLE_PEER_COMM_LOSS),           EL(CLUSTER),EC_W,   0,    EA(NONE),   "Direct communication with peer controller(s) was not established. Please check proper cable connections" },
{ EV(CTRL_FLASH_SIGNED_COMPONENT_NOT_PRESENT),EL(CTRL), EC_W,   0,    EA(NONE),   "Firmware image does not contain signed component" },
{ EV(CTRL_FLASH_AUTHENTICATION_FAILURE),    EL(CTRL),   EC_W,   0,    EA(NONE),   "Authentication failure of the signed firmware image" },
{ EV(LD_SET_BOOT_DEVICE),                   EL(LD),     EC_I,   ECB_I,EA(LD),     "Setting %s as boot device" },
{ EV(PD_SET_BOOT_DEVICE),                   EL(PD),     EC_I,   ECB_I,EA(PD),     "Setting %s as boot device" },
{ EV(BBU_TEMPERATURE_CHANGED),              EL(BBU),    EC_I,   ECB_H,EA(GENERIC),"The BBU temperature is changed to %d (Celsius)" },
{ EV(CTRL_TEMPERATURE_CHANGED),             EL(CTRL),   EC_I,   ECB_H,EA(GENERIC),"The controller temperature is changed to %d (Celsius)" },
{ EV(NVCACHE_BACKUP_UNAVAILABLE),           EL(CTRL),   EC_C,   ECB_H,EA(NONE),   "NVCache capacity is too small to support data backup. Write-back VDs will be converted to write-through" },
{ EV(NVCACHE_CONSIDER_REPLACEMENT),         EL(CTRL),   EC_W,   ECB_H,EA(NONE),   "NVCache data backup capacity has decreased, consider replacement" },
{ EV(NVCACHE_INVALID),                      EL(CTRL),   EC_C,   ECB_H,EA(NONE),   "NVCache device failed, cannot support data retention" },
{ EV(BOOT_DEVICE_INVALID),                  EL(CTRL),   EC_I,   ECB_I,EA(NONE),   "Boot Device reset, setting target ID as invalid" },
{ EV(HA_SSC_WB_POOL_SIZE_MISMATCH),         EL(CLUSTER),EC_W,   0,    EA(GENERIC),"Write back Nytro cache size mismatch between the servers. The Nytro cache size was adjusted to %ld GB"},
{ EV(HA_SSC_NONSHARED_VD_WB_ASSOCIATION),   EL(CLUSTER)+EL(LD),EC_W,0,EA(LD),     "%s is not shared between servers but assigned for caching. Write back Nytro cache content of the VD will be mirrored"},
{ EV(CTRL_POWER_IO_THROTTLE_START),         EL(CTRL),   EC_I,   ECB_H,EA(GENERIC),"Power %d watts usage base IOs throttle started" },
{ EV(CTRL_POWER_IO_THROTTLE_STOP),          EL(CTRL),   EC_I,   ECB_H,EA(NONE),   "Power base IOs throttle stopped" },
{ EV(CTRL_TUNABLE_PARAMETERS_CHANGED),      EL(CTRL),   EC_DBG, ECB_N,EA(NONE),   "Controller tunable parameter(s) changed"},
{ EV(CTRL_TEMP_WITHIN_OPTIMAL_RANGE),       EL(CTRL),   EC_I,   ECB_H,EA(NONE),   "Controller operating temperature within normal range, full operation restored"},
{ EV(CTRL_TEMP_ABOVE_OPTIMAL_RANGE),        EL(CTRL),   EC_W,   ECB_H,EA(NONE),   "Controller temperature threshold exceeded. This may indicate inadequate system cooling. Switching to low performance mode"},
{ EV(HA_MODE_HA_FEATURE_SET),               EL(CLUSTER),EC_I,   0,    EA(NONE),   "Controller supports HA mode, currently functioning with HA feature set"},
{ EV(HA_MODE_SC_FEATURE_SET),               EL(CLUSTER),EC_I,   0,    EA(NONE),   "Controller supports HA mode, currently functioning with single controller feature set" },
{ EV(NVCACHE_COMPONENT_MISMATCH),           EL(CTRL),   EC_C,   ECB_H,EA(NONE),   "Cache-vault components mismatch. Write-back VDs will be converted write-through"},
{ EV(CTRL_ENTER_MAINTENANCE_MODE),          EL(CTRL),   EC_I,   0,    EA(MODE),   "Controller has entered into maintenance mode (%d)" },
{ EV(CTRL_EXIT_MAINTENANCE_MODE),           EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller has returned to normal mode" },
{ EV(HA_TOPOLOGY_MODE),                     EL(CLUSTER),EC_I,   0,    EA(STR),    "Topology is in (%s) mode" },
{ EV(HA_TOPOLOGY_LD_INCOMPATIBLE),          EL(CLUSTER),EC_C,   0,    EA(LD_INCOMPATIBLE),     "Cannot enter (%s) mode because %s VD %s would not be supported" },
{ EV(HA_TOPOLOGY_PD_INCOMPATIBLE),          EL(CLUSTER),EC_C,   0,    EA(PD_INCOMPATIBLE),     "Cannot enter (%s) mode because %s PD %s would not be supported" },
{ EV(CTRL_CACHE_FLUSH_START),               EL(CTRL),   EC_I,   0,    EA(STR),    "%s Cache Flush started" },
{ EV(CTRL_CACHE_FLUSH_DONE),                EL(CTRL),   EC_I,   0,    EA(STR),    "%s Cache Flush finished" },
{ EV(CTRL_CACHE_FLUSH_ABORT),               EL(CTRL),   EC_I,   0,    EA(STR),    "%s Cache Flush aborted by user" },
{ EV(CTRL_PERSONALITY_CHANGE),              EL(CTRL),   EC_I,   ECB_I,EA(MODE),   "Controller personality changed to (0x%x) mode"},
{ EV(CFG_AUTO_CREATED),                     EL(CONFIG), EC_I,   0,    EA(STR),    "Configuration automatically created by %s" },
{ EV(CTRL_SWZONE_ENABLED),                  EL(CTRL),   EC_I,   0,    EA(NONE),   "Software Zone enabled"},
{ EV(CTRL_SWZONE_DISABLED),                 EL(CTRL),   EC_I,   0,    EA(NONE),   "Software Zone disabled"},
{ EV(LD_INIT_ABORTED_DUE_TO_RESET),         EL(LD),     EC_C,   ECB_B,EA(LD),     "Initialization aborted on %s due to controller reset" },
{ EV(HA_CTRL_LOCK_KEY_MISMATCH),            EL(CLUSTER),EC_C,   0,    EA(NONE),   "Peer controller security key mismatch" },
{ EV(HA_CTRL_LOCK_KEY_MATCH),               EL(CLUSTER),EC_I,   0,    EA(NONE),   "Peer controller security key match" },
{ EV(HA_LD_COMPATIBLE),                     EL(CLUSTER)+EL(LD),EC_I,0,EA(LD),     "%s is now compatible in the HA domain" },
{ EV(PD_OPERATION_DELAYED),                 EL(PD),     EC_I,   0,    EA(PDLD_OPERATION_DELAYED),       "PD %s %s delayed. Reason: %s" },
{ EV(LD_OPERATION_DELAYED),                 EL(LD),     EC_I,   0,    EA(PDLD_OPERATION_DELAYED),       "VD %s %s delayed. Reason: %s" },
{ EV(CTRL_GENERIC_MESSAGE),                 EL(CTRL),   EC_I,   0,    EA(STR),    "%s" },
{ EV(LD_VF_MAP),                            EL(LD),     EC_I,   0,    EA(LD_VF_MAP),"%s" },
{ EV(CTRL_TEMP_CRITICAL),                   EL(CTRL),   EC_C,   ECB_H,EA(NONE),   "MegaRAID Solution will shut down due to maximum temperature threshold exception. This may indicate inadequate system cooling"},
{ EV(CTRL_CHASSIS_SHUTDOWN),                EL(CTRL),   EC_I,   0,    EA(NONE),   "Shutdown chassis command received from host" },
{ EV(CTRL_CHASSIS_RESTART),                 EL(CTRL),   EC_I,   0,    EA(NONE),   "Restart chassis command received from host" },
{ EV(CTRL_INFO_CHANGED),                    EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller Information changed" },
{ EV(LD_PARTIALLY_HIDDEN),                  EL(LD),     EC_W,   0,    EA(NONE),   "Hidden policy not set for all VDs in the array"},
{ EV(PD_NOT_ENTERPRISE_SELF_ENCRYPTING_DRIVE), EL(PD),  EC_W,   0,    EA(PD),     "%s is not enterprise class self encrypting drive. Encryption capability of the drive will be disabled"},
{ EV(CTRL_FORCE_FLASH),                     EL(CTRL),   EC_I,   0,    EA(NONE),   "Controller firmware was updated with force option"},
{ EV(LD_ACCESS_POLICY_SET_TO_RW),           EL(LD),     EC_I,   0,    EA(LD),     "%s default access policy is set to read/write mode"},
{ EV(CTRL_FLASH_TRANSIENT_ERROR),           EL(CTRL),   EC_C,   ECB_H,EA(NONE),   "Disabling writes to flash due to a critical error. Reboot the system to enable writes to flash again"},
{ EV(CTRL_FLASH_FAILED),                    EL(CTRL),   EC_C,   ECB_H,EA(NONE),   "Disabling writes to flash as the part has gone bad"},
{ EV(PD_LOCATE_START),                      EL(PD),     EC_I,   0,    EA(PD),     "Locate LED started on %s"},
{ EV(PD_LOCATE_STOP),                       EL(PD),     EC_I,   0,    EA(PD),     "Locate LED stopped on %s"},
{ EV(PD_PR_CONFLICT_ABORT),                 EL(PD),     EC_I,   0,    EA(PD),     "Patrol read aborted on %s due to conflict with other background operations"},
{ EV(PD_DEGRADED_MEDIA),                    EL(PD),     EC_I,   0,    EA(PD_DEGRADED_MEDIA), "%s %s %d bad media events"},
{ EV(PD_DEGRADED_MEDIA_POOR_PERFORMANCE),   EL(PD),     EC_W,   ECB_H,EA(PD_DEGRADED_MEDIA), "%s %s has bad perf, %s"},
{ EV(BBU_SCAP_INFO),                        EL(BBU),    EC_I,   ECB_H,EA(BBU_SCAP_INFO), "SCAP HLTH: %d mF, %d mOhm, %d mV, %d Deg, 55C:x%x, 60C:x%x, 65C:x%x, 70C:x%x, 75C:x%x"},
{ EV(CTRL_PERSONALITY_PCI_CHANGE),          EL(CTRL),   EC_I,   0,    EA(PCI),    "Controller personality will change PCI ID to %04x/%04x/%04x/%04x"},
{ EV(PD_INQUIRY_INFO),                      EL(PD),     EC_I,   ECB_I,EA(PD_INQ), "%s Inquiry info: %s" },
{ EV(LD_TRANSPORT_READY),                   EL(LD),     EC_I,   0,    EA(LD),     "%s is marked as Transport Ready" },
{ EV(LD_TRANSPORT_CLEAR),                   EL(LD),     EC_I,   0,    EA(LD),     "%s is cleared from Transport Ready state" },
{ EV(SYSTEM_RESET_REQUIRED),                EL(CTRL),   EC_W,   0,    EA(NONE),   "System reset required."},
{ EV(NVCACHE_BLOCK_RECOVERY_SKIPPED),       EL(CTRL),   EC_W,   0,    EA(NONE),   "Block recovery is skipped for Cache-vault. Reboot the system to recover the blocks"},
{ EV(CTRL_AUTO_CFG_OPTION),                 EL(CTRL),   EC_I,   0,    EA(AUTO_CFG_OPTION), "Auto configuration option is set to -  %s" },
{ EV(CTRL_AUTO_CFG_PARAMETERS_CHANGED),     EL(CTRL),   EC_I,   0,    EA(NONE),   "Auto configuration parameters changed" },
{ EV(LD_TRANSPORT_READY_PRESENT_REMINDER),  EL(LD),     EC_I,   ECB_B,EA(LD),     "Reminder: Transport Ready Present %s" },
{ EV(CTRL_PROFILE_UPDATE_SUCCESSFUL),       EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Profile updated from  profile id %s" },
{ EV(CTRL_PROFILE_AUTOSELECTED),            EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Profile id %s autoselected by the firmware" },
{ EV(CTRL_PROFILE_PHYSICAL_DEVICEID_CHANGE), EL(CTRL),  EC_I,   0,    EA(NONE),   "Device Ids have been changed due to profile change. " },
{ EV(CTRL_FRU_SAVE_STATE),                  EL(CTRL),   EC_I,   0,    EA(CTRL_FRU_STATE),   "Save controller FRU State: FRU-ID 0x%llx Size 0x%x bytes"},
{ EV(CTRL_FRU_RESTORE_STATE),               EL(CTRL),   EC_I,   0,    EA(CTRL_FRU_STATE),   "Restore controller FRU State: FRU-ID 0x%llx Size 0x%x bytes"},
{ EV(CTRL_FRU_DELETE_STATE),                EL(CTRL),   EC_I,   0,    EA(CTRL_FRU_STATE),   "Delete controller FRU State: FRU-ID 0x%llx"},
{ EV(PD_ERROR_STATS),                       EL(PD),     EC_I,   0,    EA(PD_ERROR_STATS),   "%s driveErrorCounter %d slotErrorCounter %d Pd failed due to %s issue" },
{ EV(CTRL_MFC_BAD_SASADDRESS),              EL(CTRL),   EC_C,   ECB_H,EA(NONE),   "Invalid SAS Address present in MFC data" },
{ EV(SAS_TOPOLOGY_ERROR_STR),               EL(SAS),    EC_C,   0,    EA(STR),    "SAS topology error: %s" },
{ EV(CTRL_NVDATA_INVALID),                  EL(CTRL),   EC_C,   ECB_H,EA(NONE),   "Invalid NVDATA" },
{ EV(CFG_NOT_CONFIGURED),                   EL(CONFIG), EC_I,   0,    EA(NONE),   "No configuration present on the controller" },
{ EV(CFG_UNSUPPORTED),                      EL(CONFIG), EC_W,   ECB_B,EA(NONE),   "Foreign configuration unsupported by current firmware version" },
{ EV(CTRL_FLASH_BACKUP_ROM_PGM_ERROR),      EL(CTRL),   EC_W,   0,    EA(NONE),   "Backup firmware image flash programming error" },
{ EV(CTRL_FLASH_CRC_ERR_BACKUP_ACTIVATED),  EL(CTRL),   EC_W,   0,    EA(NONE),   "Active firmware image checksum error; backup firmware image activated" },
{ EV(PD_NOT_GENUINE),                       EL(PD),     EC_W,   ECB_I,EA(PD),     "%s could not be authenticated as a genuine drive" },
{ EV(PD_FAILED_AT_BOOT),                    EL(PD),     EC_W,   ECB_B,EA(NONE),   "One or more drives were failed or missing during boot" },
{ EV(CTRL_CACHE_DATA_FOUND),                EL(CTRL),   EC_W,   0,    EA(NONE),   "Data found in Write-Back cache during boot" },
{ EV(LD_DEGRADED_WRITE_HOLE),               EL(LD),     EC_W,   0,    EA(LD),     "Incomplete writes on degraded %s due to power loss; check data integrity" },
{ EV(CTRL_FEATURE_KEY_COMM_ERROR),          EL(CTRL),   EC_C,   0,    EA(NONE),   "Cannot communicate with feature key; features disabled" },
{ EV(CTRL_FLASH_IMAGE_ACTIVE),              EL(CTRL),   EC_I,   0,    EA(NONE),   "Active firmware image flash programming successful" },
{ EV(CTRL_FLASH_IMAGE_BACKUP),              EL(CTRL),   EC_I,   0,    EA(NONE),   "Backup firmware image flash programming successful" },
{ EV(CTRL_DUAL_FW_VERSION_MISMATCH),        EL(CTRL),   EC_I,   0,    EA(NONE),   "Active and backup firmware image versions do not match" },
{ EV(PACKAGE_VERSION_BACKUP),               EL(CTRL),   EC_I,   ECB_I,EA(STR),    "Backup firmware package version %s" },
{ EV(CTRL_CACHE_RESTORE_ERROR),             EL(CTRL),   EC_C,   0,    EA(NONE),   "Critical error occurred while restoring the offloaded cache data" },
{ EV(PD_LOCK_KEY_UNLOCKED_ESCROW),          EL(PD),     EC_I,   0,    EA(PD),     "Drive security key from escrow, %s is unlocked" },
{ EV(PD_TEMP_FATAL),                        EL(PD),     EC_F,   ECB_I,EA(PD_TEMP),"%s temperature (%d C) is above fatal threshold" },
{ EV(CTRL_MEMORY_ERROR),                    EL(CTRL),   EC_W,   0,    EA(NONE),   "The controller was reset to recover from a memory access error" },
{ EV(CTRL_FW_INCOMPATIBLE_WITH_PROFILE),    EL(CTRL),   EC_C,   ECB_I,EA(STR),    "Running firmware not compatible with profile id %s" },

{ EV(PD_ARRAY_DEVICE_SLOT_FAILED),          EL(PD),     EC_C,   ECB_I,EA(PD),       "%s is installed but failing to link up" },
{ EV(ENCL_TEMPERATURE_ABOVE_CRITICAL),      EL(ENCL),   EC_C,   ECB_I,EA(PD_INDEX), "Enclosure %s temperature sensor %d above critical threshold" },
{ EV(ENCL_SERVICE_CTRL_EMM_CRITICAL),       EL(ENCL),   EC_C,   ECB_I,EA(PD_INDEX), "Enclosure %s EMM %d indicates critical condition" },
{ EV(ENCL_SERVICE_CTRL_EMM_WARNING),        EL(ENCL),   EC_W,   ECB_I,EA(PD_INDEX), "Enclosure %s EMM %d indicates warning condition" },
{ EV(ENCL_ELEMENT_CRITICAL),                EL(ENCL),   EC_C,   ECB_I,EA(PD_INDEX), "Enclosure %s element %d indicates critical condition" },
{ EV(ENCL_ELEMENT_WARNING),                 EL(ENCL),   EC_W,   ECB_I,EA(PD_INDEX), "Enclosure %s element %d indicates warning condition" },
{ EV(ENCL_SAS_CONNECTOR_ERROR),             EL(ENCL),   EC_W,   ECB_I,EA(PD_INDEX), "Enclosure %s SAS connector %d has link errors" },
{ EV(CTRL_FW_VALID_SNAPDUMP_AVAILABLE),     EL(CTRL),   EC_C,   ECB_I,EA(STR),      "Number of valid snapdump available is %s" },
{ EV(CTRL_BOOT_LDS_WILL_GO_OFFLINE_EXT),    EL(CTRL),   EC_W,   ECB_B,EA(NONE),     "VDs missing drives and will go offline at boot" },
{ EV(CTRL_BOOT_LDS_MISSING_EXT),            EL(CTRL),   EC_W,   ECB_B,EA(NONE),     "VDs missing at boot" },
{ EV(CTRL_LDS_CACHE_DISCARDED_AUTO),        EL(CTRL)+EL(LD), EC_I, 0, EA(BITMAP),   "Controller cache auto discarded for VDs: %s" },
{ EV(PD_SANITIZE_FAILED),                   EL(PD),     EC_C,   0,    EA(PD_ERR), "Sanitize failed on %s (Error %02x)" },
{ EV(PD_SANITIZE_PROGRESS),                 EL(PD),     EC_P,   0,    EA(PD_PROG),"Sanitize progress on %s is %s" },
{ EV(PD_SANITIZE_STARTED),                  EL(PD),     EC_I,   ECB_B,EA(PD),     "Sanitize started on %s" },
{ EV(PD_SANITIZE_SUCCESSFUL),               EL(PD),     EC_I,   ECB_B,EA(PD),     "Sanitize completed on %s" },
{ EV(LD_CANNOT_BE_SECURED_IN_FUTURE),       EL(LD),     EC_I,   0,    EA(LD),     "%s Cannot be secured in future due to non-SED drive" },
{ EV(SYSTEM_SHUTDOWN_REQUIRED),             EL(CTRL),   EC_W,   0,    EA(NONE),   "System shutdown required"},
{ EV(LD_NON_UNMAP_CAPABLE_PD_USED),         EL(LD),     EC_W,   0,    EA(LD),     "%s Contains one or more unmap not capable PD(s)" },
{ EV(LD_UNMAP_NOT_ENABLED),                 EL(LD),     EC_I,   0,    EA(LD),     "LD %s unmap support cannot be enabled" },
{ EV(PD_SSD_WEAR_GAUGE_CHANGED),            EL(PD),     EC_I,   0,    EA(STR),     "SSD Wear Gauge values on %s" },  //"Drive %02d(e%02d/%d) PU[%02d Percent] LR[%d Days]"
{ EV(CTRL_SB_KEY_UPDATE_POWER_CYCLE),       EL(CTRL),   EC_W,   0,    EA(NONE),   "Secure Boot key update pending, power cycle the system." },
{ EV(PD_DEDICATED_NON_UNMAP_SPARE_NO_LONGER_USEFUL),  EL(PD)+EL(CONFIG),EC_W,ECB_B,EA(PD),  "Dedicated Hot Spare %s is not unmap capable and no longer useful for one or more arrays" },
{ EV(PD_NO_UNMAP_CAPABLE_PD_FOR_REBUILD), EL(PD),EC_C,ECB_H,EA(NONE),  "Rebuild not possible as Firmware did not find suitable unmap capable drive" },
{ EV(PD_NO_UNMAP_CAPABLE_PD_FOR_COPYBACK), EL(PD),EC_C,ECB_H,EA(NONE),  "Copyback not possible as Firmware did not find suitable unmap capable drive" },
};



#undef EV
#undef EC
#undef EL
#undef EA

#undef EC_DBG
#undef EC_P
#undef EC_I
#undef EC_W
#undef EC_C
#undef EC_F
#undef EC_D

#undef ECB_I
#undef ECB_H
#undef ECB_B
#undef ECB_M1
#undef ECB_M2
#undef ECB_N

#else
    extern  MR_EVT_DESCRIPTION  EventDescription[];
#endif

#endif /* INCLUDE_EVENTMSG */
